#+TITLE: 雙指針

* [[https://leetcode.cn/problems/reverse-string/][344. 反转字符串]]

#+BEGIN_SRC python :session
def reverse_string(s):
    left = 0
    right = len(s) - 1
    while left < right:
        temp = s[left]
        s[left] = s[right]
        s[right] = temp
        left += 1
        right -= 1
#+END_SRC

#+RESULTS:
: None

#+BEGIN_SRC python :session
s = ["H","a","n","n","a","h"]
reverse_string(s)
s
#+END_SRC

#+RESULTS:
| h | a | n | n | a | H |

* [[https://leetcode.cn/problems/reverse-vowels-of-a-string/][345. 反转字符串中的元音字母]]

在上一题的基础上，加一个元音判断

#+BEGIN_SRC python
def reverse_vowels(s):
    l, r = 0, len(s) - 1
    chars = list(s)
    vowels = set('aeiouAEIOU')

    while l < r:
        if s[l] not in vowels:
            l += 1
        elif s[r] not in vowels:
            r -= 1
        else:
            chars[l], chars[r] = chars[r], chars[l]
            l += 1
            r -= 1

    return ''.join(chars)
#+END_SRC

* [[https://leetcode.cn/problems/flip-square-submatrix-vertically/description/][3643. 垂直翻转子矩阵]]

#+BEGIN_SRC python
def reverse_submatrix(grid, x, y, k):
    for i in range(y, y + k):
        top = x
        bottom = x + k - 1
        while top < bottom:
            grid[top][i], grid[bottom][i] = grid[bottom][i], grid[top][i]
            top += 1
            bottom -= 1
    return grid
#+END_SRC

* [[https://leetcode.cn/problems/minimum-length-of-string-after-deleting-similar-ends/description/][1750. 删除字符串两端相同字符后的最短长度]]

不能相交，长度1直接返回，left < right
前缀后缀要所有字符相同

#+BEGIN_SRC python :session
def minimum_length(s):
    left, right = 0, len(s) - 1
    while left < right and s[left] == s[right]:
        c = s[left]
        while left <= right and s[left] == c:
            left += 1
        while left <= right and s[right] == c:
            right -= 1
    return right - left + 1
#+END_SRC

#+RESULTS:
: None

测试：

#+BEGIN_SRC python :session
minimum_length("ca")
#+END_SRC

#+RESULTS:
: 2

#+BEGIN_SRC python :session
minimum_length("cabaabac")
#+END_SRC

#+RESULTS:
: 0

#+BEGIN_SRC python :session
minimum_length("aabccabba")
#+END_SRC

#+RESULTS:
: 3

* [[https://leetcode.cn/problems/watering-plants-ii/][2105. 给植物浇水 II]]

#+BEGIN_SRC python :session
def minimum_refill(plants, capacity_a, capacity_b):
    ans = 0

    # a b 当前水量
    a = capacity_a
    b = capacity_b

    # a b 当前位置
    left = 0
    right = len(plants) - 1

    while left < right:
        # a的水不够，补充水，答案加1
        if a < plants[left]:
            a = capacity_a
            ans += 1
        # a浇水，右移
        a -= plants[left]
        left += 1

        # b的水不够，补水，答案加1
        if b < plants[right]:
            b = capacity_b
            ans += 1
        # b浇水，左移
        b -= plants[right]
        right -= 1

    # a b 相遇，如果水不够答案再加1
    if left == right and max(a, b) < plants[left]:
        ans += 1
    return ans
#+END_SRC

#+RESULTS:
: None

测试：

#+BEGIN_SRC python :session
minimum_refill([2,2,3,3], 5, 5)
#+END_SRC

#+RESULTS:
: 1

#+BEGIN_SRC python :session
minimum_refill([2,2,3,3], 3, 4)
#+END_SRC

#+RESULTS:
: 2

* [[https://leetcode.cn/problems/squares-of-a-sorted-array/description/][977. 有序数组的平方]]

最简单的方式就是直接map平方再排序，但是数组非递减的性质没有利用到。

可以找出数组负数和非负数的分界位置，做归并排序。

先写一个找出分界位置的函数：

#+BEGIN_SRC python :session
import bisect

def find_boundary(nums):
    first_non_negative = bisect.bisect_left(nums, 0)
    return first_non_negative - 1, first_non_negative
#+END_SRC

#+RESULTS:
: None

测试一下：

#+BEGIN_SRC python :session
find_boundary([-4,-1,0,3,10])
#+END_SRC

#+RESULTS:
| 1 | 2 |

#+BEGIN_SRC python :session
find_boundary([2, 8, 10])
#+END_SRC

#+RESULTS:
| -1 | 0 |

没有负数也没关系

#+BEGIN_SRC python :session
def sorted_squares(nums):
    i, j = find_boundary(nums)
    ans = []
    while i >= 0 or j < len(nums):
        # 先处理两个边界情况
        if i < 0:
            ans.append(nums[j] ** 2)
            j += 1
        elif j == len(nums):
            ans.append(nums[i] ** 2)
            i -= 1
        else:
            x = nums[i] ** 2
            y = nums[j] ** 2
            # 小的先进
            if x < y:
                ans.append(x)
                i -= 1
            else:
                ans.append(y)
                j += 1
    return ans
#+END_SRC

#+RESULTS:
: None

如果把数组分成正负两个部分，负数部分的平方是非递增的，非负数部分的平方是非递减的。这样可以把双指针分别放在数组开头和结尾，相当于做归并排序，从右往左、从大到小更新答案。

#+BEGIN_SRC python :session
def sorted_squares(nums):
    n = len(nums)
    ans = [0] * n
    left, right = 0, n - 1

    # 倒着更新
    for i in range(n - 1, -1, -1):
        l_square = nums[left] ** 2
        r_square = nums[right] ** 2
        if l_square > r_square:
            ans[i] = l_square
            left += 1
        else:
            ans[i] = r_square
            right -= 1
    return ans
#+END_SRC

在循环过程中，还可以利用原数组有序的特性，省略重复的平方运算，比如比较​=abs(nums[left]) > nums[right]=​，或者​=-nums[left] > nums[right]=​。

* [[https://leetcode.cn/problems/bag-of-tokens/description/][948. 令牌放置]]

直觉上，应该用最小的能量换分，直到能量不够，用分数换最大的能量。可以先从小到大排序令牌，再用相向双指针，能量够就从左边最小的令牌换分，能量不够就从右边最大的令牌换能量。

#+BEGIN_SRC python :session
def bag_of_tokens_score(tokens, power):
    tokens.sort()
    score = 0
    left, right = 0, len(tokens) - 1
    while left <= right:
        # 能量足够，换取分数
        if power >= tokens[left]:
            power -= tokens[left]
            left += 1
            score += 1
        # 能量不够，兑换能量
        elif score > 0:
            power += tokens[right]
            right -= 1
            score -= 1
        # 能量和分数都不足，直接退出
        else:
            break
    return score
#+END_SRC

#+RESULTS:
: None

测试：

#+BEGIN_SRC python :session
bag_of_tokens_score([200,100], 150) # 答案应该是1
#+END_SRC

#+RESULTS:
: 0

代码有漏洞，当能量不够的时候，不一定非得兑换能量。要想得分最高，最后一次操作必需是消耗能量换分，这个时候再用分换能量没有意义。

#+BEGIN_SRC python :session
def bag_of_tokens_score(tokens, power):
    tokens.sort()
    score = 0
    left, right = 0, len(tokens) - 1
    while left <= right:
        # 能量足够，换取分数
        if power >= tokens[left]:
            power -= tokens[left]
            left += 1
            score += 1
        # 能量不够，兑换能量，但要兑换后还能再获得分数
        elif score > 0 and right > left and (power + tokens[right]) > tokens[left]:
            power += tokens[right]
            right -= 1
            score -= 1
        # 能量和分数都不足，直接退出
        else:
            break
    return score
#+END_SRC

#+RESULTS:
: None

测试：

#+BEGIN_SRC python :session
bag_of_tokens_score([200,100], 150) # 答案应该是1
#+END_SRC

#+RESULTS:
: 1

* [[https://leetcode.cn/problems/reverse-only-letters/][917. 仅仅反转字母]]

#+BEGIN_SRC scheme :session
(define (reverse-only-letters s)
  (define (letter? c)
    (or (char<=? #\a c #\z)
        (char<=? #\A c #\Z)))
  (let loop ((left 0)
             (right (- (string-length s) 1)))
    (if (< left right)
        (let* ((left-letter? (letter? (string-ref s left)))
               (right-letter? (letter? (string-ref s right)))
               (swap? (and left-letter? right-letter?))
               (left-offset (if left-letter? 0 1))
               (right-offset (if right-letter? 0 1)))
          (if swap?
              (let ((temp (string-ref s left)))
                (string-set! s left (string-ref s right))
                (string-set! s right temp)
                (loop (+ left 1)
                      (- right 1)))
              (loop (+ left left-offset)
                    (- right right-offset))))
        s)))
#+END_SRC

#+RESULTS:
: #<unspecified>

测试：

#+BEGIN_SRC scheme :session
(reverse-only-letters (string-copy "ab-cd"))
#+END_SRC

#+RESULTS:
: dc-ba

* [[https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/][167. 两数之和 II - 输入有序数组]]

#+BEGIN_SRC scheme :session
(define (two-sum numbers target)
  (let loop ((left 0)
             (right (- (vector-length numbers) 1)))
    (if (< left right)
        (let ((sum (+ (vector-ref numbers left)
                      (vector-ref numbers right))))
          (cond
           ((> sum target) (loop left (- right 1)))
           ((< sum target) (loop (+ left 1) right))
           (else (list left right))))
        (list -1 -1))))
#+END_SRC

#+RESULTS:
: #<unspecified>

测试：

#+BEGIN_SRC scheme :session
(two-sum #(2 7 11 15) 9)
#+END_SRC

#+RESULTS:
| 0 | 1 |

题目有个小陷阱，下标从1开始，只要最后返回的地方两个指针都加一就可以了

#+BEGIN_SRC scheme
(define (two-sum numbers target)
  (let loop ((left 0)
             (right (- (vector-length numbers) 1)))
    (if (< left right)
        (let ((sum (+ (vector-ref numbers left)
                      (vector-ref numbers right))))
          (cond
           ((> sum target) (loop left (- right 1)))
           ((< sum target) (loop (+ left 1) right))
           (else (list (+ left 1) (+ right 1)))))
        (list -1 -1))))
#+END_SRC

* [[https://leetcode.cn/problems/sum-of-square-numbers/][633. 平方数之和]]

a和b只可能比c小，而且最多到根号c（向下取整）

题目说明了是整数里找，算平方，负数可以排除，相当于上一题的变种，在有序的自然数里找

#+BEGIN_SRC scheme :session
(sqrt 25)
#+END_SRC

#+RESULTS:
: 5

#+BEGIN_SRC scheme :session
(sqrt 26)
#+END_SRC

#+RESULTS:
: 5.0990195135927845

开方再向下取整：

#+BEGIN_SRC scheme :session
(inexact->exact (floor (sqrt 26)))
#+END_SRC

#+RESULTS:
: 5

#+BEGIN_SRC scheme :session
(define (judge-square-sum c)
  (let loop ((left 0)
             (right (inexact->exact (floor (sqrt c)))))
    (if (< left right)
        (let ((sum (+ (* left left)
                      (* right right))))
          (cond
           ((> sum c) (loop left (- right 1)))
           ((< sum c) (loop (+ left 1) right))
           (else #t)))
        #f)))
#+END_SRC

#+RESULTS:
: #<unspecified>

#+BEGIN_SRC scheme :session
(judge-square-sum 5)
#+END_SRC

#+RESULTS:
: #t

+提交后报错，题目没说两个整数可以是一样的！循环条件小于改成小于等于后可以通过。+

正负数平方后是相同的，但是以2为例，可以是1的平方加-1的平方，所以循环条件确实应该是小于等于。

* [[https://leetcode.cn/problems/count-pairs-whose-sum-is-less-than-target/][2824. 统计和小于目标的下标对数目]]

#+BEGIN_SRC scheme :session
(define (count-pairs nums target)
  (let ((sorted (sort nums <)))
    (let loop ((left 0)
               (right (- (vector-length sorted) 1))
               (ans 0))
      (if (< left right)
          (let ((sum (+ (vector-ref sorted left)
                        (vector-ref sorted right))))
            (if (< sum target)
                (loop (+ left 1)
                      right
                      (+ ans (- right left)))
                (loop left
                      (- right 1)
                      ans)))
          ans))))
#+END_SRC

#+RESULTS:
: #<unspecified>

测试：

#+BEGIN_SRC scheme :session
(count-pairs #(-1 1 2 3 1) 2)
#+END_SRC

#+RESULTS:
: 3

#+BEGIN_SRC scheme :session
(count-pairs #(-6 2 5 -2 -7 -1 3) -2)
#+END_SRC

#+RESULTS:
: 10

#+TITLE: 雙指針

* [[https://leetcode.cn/problems/reverse-string/][344. 反转字符串]]

#+BEGIN_SRC python :session
def reverse_string(s):
    left = 0
    right = len(s) - 1
    while left < right:
        temp = s[left]
        s[left] = s[right]
        s[right] = temp
        left += 1
        right -= 1
#+END_SRC

#+RESULTS:
: None

#+BEGIN_SRC python :session
s = ["H","a","n","n","a","h"]
reverse_string(s)
s
#+END_SRC

#+RESULTS:
| h | a | n | n | a | H |

* [[https://leetcode.cn/problems/reverse-vowels-of-a-string/][345. 反转字符串中的元音字母]]

在上一题的基础上，加一个元音判断

#+BEGIN_SRC python
def reverse_vowels(s):
    l, r = 0, len(s) - 1
    chars = list(s)
    vowels = set('aeiouAEIOU')

    while l < r:
        if s[l] not in vowels:
            l += 1
        elif s[r] not in vowels:
            r -= 1
        else:
            chars[l], chars[r] = chars[r], chars[l]
            l += 1
            r -= 1

    return ''.join(chars)
#+END_SRC

* [[https://leetcode.cn/problems/flip-square-submatrix-vertically/description/][3643. 垂直翻转子矩阵]]

#+BEGIN_SRC python
def reverse_submatrix(grid, x, y, k):
    for i in range(y, y + k):
        top = x
        bottom = x + k - 1
        while top < bottom:
            grid[top][i], grid[bottom][i] = grid[bottom][i], grid[top][i]
            top += 1
            bottom -= 1
    return grid
#+END_SRC

* [[https://leetcode.cn/problems/minimum-length-of-string-after-deleting-similar-ends/description/][1750. 删除字符串两端相同字符后的最短长度]]

不能相交，长度1直接返回，left < right
前缀后缀要所有字符相同

#+BEGIN_SRC python :session
def minimum_length(s):
    left, right = 0, len(s) - 1
    while left < right and s[left] == s[right]:
        c = s[left]
        while left <= right and s[left] == c:
            left += 1
        while left <= right and s[right] == c:
            right -= 1
    return right - left + 1
#+END_SRC

#+RESULTS:
: None

测试：

#+BEGIN_SRC python :session
minimum_length("ca")
#+END_SRC

#+RESULTS:
: 2

#+BEGIN_SRC python :session
minimum_length("cabaabac")
#+END_SRC

#+RESULTS:
: 0

#+BEGIN_SRC python :session
minimum_length("aabccabba")
#+END_SRC

#+RESULTS:
: 3

* [[https://leetcode.cn/problems/watering-plants-ii/][2105. 给植物浇水 II]]

#+BEGIN_SRC python :session
def minimum_refill(plants, capacity_a, capacity_b):
    ans = 0

    # a b 当前水量
    a = capacity_a
    b = capacity_b

    # a b 当前位置
    left = 0
    right = len(plants) - 1

    while left < right:
        # a的水不够，补充水，答案加1
        if a < plants[left]:
            a = capacity_a
            ans += 1
        # a浇水，右移
        a -= plants[left]
        left += 1

        # b的水不够，补水，答案加1
        if b < plants[right]:
            b = capacity_b
            ans += 1
        # b浇水，左移
        b -= plants[right]
        right -= 1

    # a b 相遇，如果水不够答案再加1
    if left == right and max(a, b) < plants[left]:
        ans += 1
    return ans
#+END_SRC

#+RESULTS:
: None

测试：

#+BEGIN_SRC python :session
minimum_refill([2,2,3,3], 5, 5)
#+END_SRC

#+RESULTS:
: 1

#+BEGIN_SRC python :session
minimum_refill([2,2,3,3], 3, 4)
#+END_SRC

#+RESULTS:
: 2

* [[https://leetcode.cn/problems/squares-of-a-sorted-array/description/][977. 有序数组的平方]]

最简单的方式就是直接map平方再排序，但是数组非递减的性质没有利用到。

可以找出数组负数和非负数的分界位置，做归并排序。

先写一个找出分界位置的函数：

#+BEGIN_SRC python :session
import bisect

def find_boundary(nums):
    first_non_negative = bisect.bisect_left(nums, 0)
    return first_non_negative - 1, first_non_negative
#+END_SRC

#+RESULTS:
: None

测试一下：

#+BEGIN_SRC python :session
find_boundary([-4,-1,0,3,10])
#+END_SRC

#+RESULTS:
| 1 | 2 |

#+BEGIN_SRC python :session
find_boundary([2, 8, 10])
#+END_SRC

#+RESULTS:
| -1 | 0 |

没有负数也没关系

#+BEGIN_SRC python :session
def sorted_squares(nums):
    i, j = find_boundary(nums)
    ans = []
    while i >= 0 or j < len(nums):
        # 先处理两个边界情况
        if i < 0:
            ans.append(nums[j] ** 2)
            j += 1
        elif j == len(nums):
            ans.append(nums[i] ** 2)
            i -= 1
        else:
            x = nums[i] ** 2
            y = nums[j] ** 2
            # 小的先进
            if x < y:
                ans.append(x)
                i -= 1
            else:
                ans.append(y)
                j += 1
    return ans
#+END_SRC

#+RESULTS:
: None

如果把数组分成正负两个部分，负数部分的平方是非递增的，非负数部分的平方是非递减的。这样可以把双指针分别放在数组开头和结尾，相当于做归并排序，从右往左、从大到小更新答案。

#+BEGIN_SRC python :session
def sorted_squares(nums):
    n = len(nums)
    ans = [0] * n
    left, right = 0, n - 1

    # 倒着更新
    for i in range(n - 1, -1, -1):
        l_square = nums[left] ** 2
        r_square = nums[right] ** 2
        if l_square > r_square:
            ans[i] = l_square
            left += 1
        else:
            ans[i] = r_square
            right -= 1
    return ans
#+END_SRC

在循环过程中，还可以利用原数组有序的特性，省略重复的平方运算，比如比较​=abs(nums[left]) > nums[right]=​，或者​=-nums[left] > nums[right]=​。

* [[https://leetcode.cn/problems/bag-of-tokens/description/][948. 令牌放置]]

直觉上，应该用最小的能量换分，直到能量不够，用分数换最大的能量。可以先从小到大排序令牌，再用相向双指针，能量够就从左边最小的令牌换分，能量不够就从右边最大的令牌换能量。

#+BEGIN_SRC python :session
def bag_of_tokens_score(tokens, power):
    tokens.sort()
    score = 0
    left, right = 0, len(tokens) - 1
    while left <= right:
        # 能量足够，换取分数
        if power >= tokens[left]:
            power -= tokens[left]
            left += 1
            score += 1
        # 能量不够，兑换能量
        elif score > 0:
            power += tokens[right]
            right -= 1
            score -= 1
        # 能量和分数都不足，直接退出
        else:
            break
    return score
#+END_SRC

#+RESULTS:
: None

测试：

#+BEGIN_SRC python :session
bag_of_tokens_score([200,100], 150) # 答案应该是1
#+END_SRC

#+RESULTS:
: 0

代码有漏洞，当能量不够的时候，不一定非得兑换能量。要想得分最高，最后一次操作必需是消耗能量换分，这个时候再用分换能量没有意义。

#+BEGIN_SRC python :session
def bag_of_tokens_score(tokens, power):
    tokens.sort()
    score = 0
    left, right = 0, len(tokens) - 1
    while left <= right:
        # 能量足够，换取分数
        if power >= tokens[left]:
            power -= tokens[left]
            left += 1
            score += 1
        # 能量不够，兑换能量，但要兑换后还能再获得分数
        elif score > 0 and right > left and (power + tokens[right]) > tokens[left]:
            power += tokens[right]
            right -= 1
            score -= 1
        # 能量和分数都不足，直接退出
        else:
            break
    return score
#+END_SRC

#+RESULTS:
: None

测试：

#+BEGIN_SRC python :session
bag_of_tokens_score([200,100], 150) # 答案应该是1
#+END_SRC

#+RESULTS:
: 1

* [[https://leetcode.cn/problems/reverse-only-letters/][917. 仅仅反转字母]]

#+BEGIN_SRC scheme :session
(define (reverse-only-letters s)
  (define (letter? c)
    (or (char<=? #\a c #\z)
        (char<=? #\A c #\Z)))
  (let loop ((left 0)
             (right (- (string-length s) 1)))
    (if (< left right)
        (let* ((left-letter? (letter? (string-ref s left)))
               (right-letter? (letter? (string-ref s right)))
               (swap? (and left-letter? right-letter?))
               (left-offset (if left-letter? 0 1))
               (right-offset (if right-letter? 0 1)))
          (if swap?
              (let ((temp (string-ref s left)))
                (string-set! s left (string-ref s right))
                (string-set! s right temp)
                (loop (+ left 1)
                      (- right 1)))
              (loop (+ left left-offset)
                    (- right right-offset))))
        s)))
#+END_SRC

#+RESULTS:
: #<unspecified>

测试：

#+BEGIN_SRC scheme :session
(reverse-only-letters (string-copy "ab-cd"))
#+END_SRC

#+RESULTS:
: dc-ba

* [[https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/][167. 两数之和 II - 输入有序数组]]

#+BEGIN_SRC scheme :session
(define (two-sum numbers target)
  (let loop ((left 0)
             (right (- (vector-length numbers) 1)))
    (if (< left right)
        (let ((sum (+ (vector-ref numbers left)
                      (vector-ref numbers right))))
          (cond
           ((> sum target) (loop left (- right 1)))
           ((< sum target) (loop (+ left 1) right))
           (else (list left right))))
        (list -1 -1))))
#+END_SRC

#+RESULTS:
: #<unspecified>

测试：

#+BEGIN_SRC scheme :session
(two-sum #(2 7 11 15) 9)
#+END_SRC

#+RESULTS:
| 0 | 1 |

题目有个小陷阱，下标从1开始，只要最后返回的地方两个指针都加一就可以了

#+BEGIN_SRC scheme
(define (two-sum numbers target)
  (let loop ((left 0)
             (right (- (vector-length numbers) 1)))
    (if (< left right)
        (let ((sum (+ (vector-ref numbers left)
                      (vector-ref numbers right))))
          (cond
           ((> sum target) (loop left (- right 1)))
           ((< sum target) (loop (+ left 1) right))
           (else (list (+ left 1) (+ right 1)))))
        (list -1 -1))))
#+END_SRC

* [[https://leetcode.cn/problems/sum-of-square-numbers/][633. 平方数之和]]

a和b只可能比c小，而且最多到根号c（向下取整）

题目说明了是整数里找，算平方，负数可以排除，相当于上一题的变种，在有序的自然数里找

#+BEGIN_SRC scheme :session
(sqrt 25)
#+END_SRC

#+RESULTS:
: 5

#+BEGIN_SRC scheme :session
(sqrt 26)
#+END_SRC

#+RESULTS:
: 5.0990195135927845

开方再向下取整：

#+BEGIN_SRC scheme :session
(inexact->exact (floor (sqrt 26)))
#+END_SRC

#+RESULTS:
: 5

#+BEGIN_SRC scheme :session
(define (judge-square-sum c)
  (let loop ((left 0)
             (right (inexact->exact (floor (sqrt c)))))
    (if (< left right)
        (let ((sum (+ (* left left)
                      (* right right))))
          (cond
           ((> sum c) (loop left (- right 1)))
           ((< sum c) (loop (+ left 1) right))
           (else #t)))
        #f)))
#+END_SRC

#+RESULTS:
: #<unspecified>

#+BEGIN_SRC scheme :session
(judge-square-sum 5)
#+END_SRC

#+RESULTS:
: #t

+提交后报错，题目没说两个整数可以是一样的！循环条件小于改成小于等于后可以通过。+

正负数平方后是相同的，但是以2为例，可以是1的平方加-1的平方，所以循环条件确实应该是小于等于。

* [[https://leetcode.cn/problems/count-pairs-whose-sum-is-less-than-target/][2824. 统计和小于目标的下标对数目]]

#+BEGIN_SRC scheme :session
(define (count-pairs nums target)
  (let ((sorted (sort nums <)))
    (let loop ((left 0)
               (right (- (vector-length sorted) 1))
               (ans 0))
      (if (< left right)
          (let ((sum (+ (vector-ref sorted left)
                        (vector-ref sorted right))))
            (if (< sum target)
                (loop (+ left 1)
                      right
                      (+ ans (- right left)))
                (loop left
                      (- right 1)
                      ans)))
          ans))))
#+END_SRC

#+RESULTS:
: #<unspecified>

测试：

#+BEGIN_SRC scheme :session
(count-pairs #(-1 1 2 3 1) 2)
#+END_SRC

#+RESULTS:
: 3

#+BEGIN_SRC scheme :session
(count-pairs #(-6 2 5 -2 -7 -1 3) -2)
#+END_SRC

#+RESULTS:
: 10

* [[https://leetcode.cn/problems/3sum/description/][15. 三数之和]]

需要x,y,z和等於0，固定x，找y + x = -x，變成雙指針問題

先試試在有序的數組中，找y和z：

#+BEGIN_SRC scheme :session
(define (find-y-z nums x)
  (let loop ((left 0)
             (right (- (vector-length nums) 1))
             (ans '()))
    (if (< left right)
        (let* ((y (vector-ref nums left))
               (z (vector-ref nums right))
               (sum (+ y z))
               (neg-x (- x)))
          (cond
           ((> sum neg-x) (loop left (- right 1) ans))
           ((< sum neg-x) (loop (+ left 1) right ans))
           (else (loop (+ left 1)
                       (- right 1)
                       (cons (list y z) ans)))))
        ans)))
#+END_SRC

#+RESULTS:
: #<unspecified>

測試：

#+BEGIN_SRC scheme :session
(find-y-z #(-4 -1 -1 0 1 2) -1)
#+END_SRC

#+RESULTS:
|  0 | 1 |
| -1 | 2 |

將返回值改造下，返回xyz：

#+BEGIN_SRC scheme :session
(define (find-x-y-z nums x)
  (let loop ((left 0)
             (right (- (vector-length nums) 1))
             (ans '()))
    (if (< left right)
        (let* ((y (vector-ref nums left))
               (z (vector-ref nums right))
               (sum (+ y z))
               (neg-x (- x)))
          (cond
           ((> sum neg-x) (loop left (- right 1) ans))
           ((< sum neg-x) (loop (+ left 1) right ans))
           (else (loop (+ left 1)
                       (- right 1)
                       (cons (list x y z) ans)))))
        ans)))
#+END_SRC

但是還要處理去重，如果遍歷nums，應該要跳過重複的x，雙指針的左端點也不應該每次都從0開始了

#+BEGIN_SRC scheme :session
(define (find-x-y-z nums x start)
  (let loop ((left start)
             (right (- (vector-length nums) 1))
             (ans '()))
    (if (< left right)
        (let* ((y (vector-ref nums left))
               (z (vector-ref nums right))
               (sum (+ y z))
               (neg-x (- x)))
          (cond
           ((> sum neg-x) (loop left (- right 1) ans))
           ((< sum neg-x) (loop (+ left 1) right ans))
           (else (loop (+ left 1)
                       (- right 1)
                       (cons (list x y z) ans)))))
        ans)))

(define (three-sum nums)
  (let ((len (vector-length nums))
        (sorted (sort nums <)))
    (let loop ((i 0)
               (result '()))
      (if (< i len)
          (if (and (> i 0)
                   (eq? (vector-ref sorted i)
                        (vector-ref sorted (- i 1))))
              (loop (+ i 1) result)
              (let ((new-ans (find-x-y-z sorted
                                         (vector-ref sorted i)
                                         (+ i 1))))
                (loop (+ i 1)
                      (append result new-ans))))
          result))))
#+END_SRC

#+RESULTS:
: #<unspecified>

#+BEGIN_SRC scheme :session
(three-sum #(2 -3 0 -2 -5 -5 -4 1 2 -2 2 0 2 -4 5 5 -10))
#+END_SRC

#+RESULTS:
| -10 |  5 | 5 |
|  -5 |  0 | 5 |
|  -5 |  0 | 5 |
|  -4 |  2 | 2 |
|  -4 |  2 | 2 |
|  -3 |  1 | 2 |
|  -3 | -2 | 5 |
|  -3 | -2 | 5 |
|  -2 |  0 | 2 |
|  -2 |  0 | 2 |

還是有重複，只跳過了重複的x，沒有考慮y和z也會重複。

#+BEGIN_SRC scheme :session
(define (find-x-y-z nums x start end)
  (let loop ((left start)
             (right end)
             (ans '()))
    (if (< left right)
        (let* ((y (vector-ref nums left))
               (z (vector-ref nums right))
               (sum (+ y z))
               (neg-x (- x)))
          (cond
           ((and (> left start)
                 (eq? (vector-ref nums (- left 1)) y))
            (loop (+ left 1) right ans))
           ((and (< right end)
                 (eq? (vector-ref nums (+ right 1)) z))
            (loop left (- right 1) ans))
           ((> sum neg-x) (loop left (- right 1) ans))
           ((< sum neg-x) (loop (+ left 1) right ans))
           (else (loop (+ left 1)
                       (- right 1)
                       (cons (list x y z) ans)))))
        ans)))

(define (three-sum nums)
  (let ((len (vector-length nums))
        (sorted (sort nums <)))
    (let loop ((i 0)
               (result '()))
      (if (< i len)
          (if (and (> i 0)
                   (eq? (vector-ref sorted i)
                        (vector-ref sorted (- i 1))))
              (loop (+ i 1) result)
              (let ((new-ans (find-x-y-z sorted
                                         (vector-ref sorted i)
                                         (+ i 1)
                                         (- len 1))))
                (loop (+ i 1)
                      (append result new-ans))))
          result))))
#+END_SRC

#+RESULTS:
: #<unspecified>

#+BEGIN_SRC scheme :session
(three-sum #(2 -3 0 -2 -5 -5 -4 1 2 -2 2 0 2 -4 5 5 -10))
#+END_SRC

#+RESULTS:
| -10 |  5 | 5 |
|  -5 |  0 | 5 |
|  -4 |  2 | 2 |
|  -3 |  1 | 2 |
|  -3 | -2 | 5 |
|  -2 |  0 | 2 |

沒有重複了，提交通過，完成。

還能做一些優化，按升序排序後，如果xyz和大於0了，後面的數再相加只會更大，可以直接跳出循環過程，但算法時間複雜度​=O(N^2)=​不能再優化了。

* [[https://leetcode.cn/problems/3sum-closest/description/][16. 最接近的三数之和]]

#+BEGIN_SRC scheme :session
(define (three-sum-closest nums target)
  (let ((len (vector-length nums))
        (sorted (sort nums <))
        (answer +inf.0)
        (min-gap +inf.0))
    (let outer-loop ((i 0))
      (when (< i len)
        ;; 跳过重复的i
        (if (and (> i 0)
                 (eq? (vector-ref sorted i)
                      (vector-ref sorted (- i 1))))
            (outer-loop (+ i 1))
            (let ((x (vector-ref sorted i)))
              (let inner-loop ((j (+ i 1))
                               (k (- len 1)))
                (when (< j k)
                  (let* ((y (vector-ref sorted j))
                         (z (vector-ref sorted k))
                         (sum (+ x y z))
                         (gap (abs (- sum target))))
                    (when (< gap min-gap)
                      (set! min-gap gap)
                      (set! answer sum))
                    (cond
                     ((< sum target)
                      (let loop ((new-j (+ j 1)))
                        (if (and (< new-j k)
                                 (eq? (vector-ref sorted new-j)
                                      (vector-ref sorted j)))
                            (loop (+ new-j 1))
                            (inner-loop new-j k))))
                     ((> sum target)
                      (let loop ((new-k (- k 1)))
                        (if (and (> new-k j)
                                 (eq? (vector-ref sorted new-k)
                                      (vector-ref sorted k)))
                            (loop (- new-k 1))
                            (inner-loop j new-k))))
                     (else
                      (set! answer sum)
                      (set! min-gap 0))))))
              (outer-loop (+ i 1))))))
    answer))
#+END_SRC

#+RESULTS:
: #<unspecified>

测试：

#+BEGIN_SRC scheme :session
(three-sum-closest #(-1 2 1 -4) 1)
#+END_SRC

#+RESULTS:
: 2

#+BEGIN_SRC scheme :session
(three-sum-closest #(0 0 0) 1)
#+END_SRC

#+RESULTS:
: 0

* [[https://leetcode.cn/problems/4sum/description/][18. 四数之和]]

#+BEGIN_SRC scheme :session
(define (four-sum nums target)
  (let ((len (vector-length nums))
        (sorted (sort nums <)))
    (define (outer-loop i ans)
      (if (>= i (- len 3))
          ans
          (let ((a (vector-ref sorted i)))
            (cond
             ;; 跳过重复
             ((and (> i 0)
                   (eq? a (vector-ref sorted (- i 1))))
              (outer-loop (+ i 1) ans))
             
             ;; 排序后四数超过了target，没有再往后找的必要了
             ((and (< (+ i 3) len)
                   (> (+ a
                         (vector-ref sorted (+ i 1))
                         (vector-ref sorted (+ i 2))
                         (vector-ref sorted (+ i 3)))
                      target))
              ans)
             
             (else
              (inner-loop (+ i 1) i a ans))))))
    
    (define (inner-loop j i a ans)
      (if (>= j (- len 2))
          (outer-loop (+ i 1) ans)
          (let ((b (vector-ref sorted j)))
            (cond
             ;; 跳过重复
             ((and (> j (+ i 1))
                   (eq? b (vector-ref sorted (- j 1))))
              (inner-loop (+ j 1) i a ans))
             
             (else
              (two-pointer-loop (+ j 1) (- len 1) i j a b ans))))))
    
    (define (two-pointer-loop left right i j a b ans)
      (if (>= left right)
          (inner-loop (+ j 1) i a ans)
          (let* ((c (vector-ref sorted left))
                 (d (vector-ref sorted right))
                 (sum (+ a b c d)))
            (cond
             ;; 跳过重复
             ((and (> left (+ j 1))
                   (eq? c (vector-ref sorted (- left 1))))
              (two-pointer-loop (+ left 1) right i j a b ans))
             
             ;; 跳过重复
             ((and (< right (- len 1))
                   (eq? d (vector-ref sorted (+ right 1))))
              (two-pointer-loop left (- right 1) i j a b ans))
             
             ((> sum target)
              (two-pointer-loop left (- right 1) i j a b ans))
             
             ((< sum target)
              (two-pointer-loop (+ left 1) right i j a b ans))
             
             (else
              (let ((new-ans (cons (list a b c d) ans)))
                (two-pointer-loop (+ left 1) (- right 1) i j a b new-ans)))))))
    
    (outer-loop 0 '())))
#+END_SRC

#+RESULTS:
: #<unspecified>

测试：

#+BEGIN_SRC scheme :session
(four-sum #(1 0 -1 0 -2 2) 0)
#+END_SRC

#+RESULTS:
| -1 |  0 | 0 | 1 |
| -2 |  0 | 0 | 2 |
| -2 | -1 | 1 | 2 |

* [[https://leetcode.cn/problems/3sum-with-multiplicity/description/][923. 三数之和的多种可能]]

题目要求最后答案要除一下这个常量：

#+BEGIN_SRC scheme :session
(define MOD 1000000007)
#+END_SRC

#+RESULTS:
: #<unspecified>

和三数之和比，不用去重，但是要想出怎么算所有的可能。

假设按求三数之和的方法，固定第一个数，双指针刚刚找到了满足条件的两个数，这时有两种情况：

1. 两个数相等，由于已经排序了，说明双指针之间所有数都一样，可能的组合就是​=C(k, 2)=​，k是这个数的计数。并且这时双指针循环可以结束，因为中间没有不同的数了。
2. 两个数不相等，设区间内和左指针下数相同的有m个，和右指针下数相同的有n个，那就是从m中取1个，再从n中取1个，组合数是m * n。另外在区间中间，可能还有符合条件的其它数，所以双指针循环还要继续。

第一种情况可以直接跳出双指针循环，第二种情况需要两边分别计数，先为第二种写一个函数：

#+BEGIN_SRC scheme :session
(define (count-rest-two arr left right)
  (let ((a (vector-ref arr left))
        (b (vector-ref arr right)))
    (let loop ((start (+ left 1))
               (end (- right 1))
               (l-count 1)
               (r-count 1))
      (if (<= start end)
          (cond
           ((eq? a (vector-ref arr start))
            (loop (+ start 1)
                  end
                  (+ l-count 1)
                  r-count))
           ((eq? b (vector-ref arr end))
            (loop start
                  (- end 1)
                  l-count
                  (+ r-count 1)))
           (else (* l-count r-count)))
          (* l-count r-count)))))
#+END_SRC

#+RESULTS:
: #<unspecified>

测试一下：

#+BEGIN_SRC scheme :session
(count-rest-two #(1 2 2 2 4 4) 1 5)
#+END_SRC

#+RESULTS:
: 6

#+BEGIN_SRC scheme :session
(count-rest-two #(1 2 3 4 4) 1 4)
#+END_SRC

#+RESULTS:
: 2

#+BEGIN_SRC scheme :session
(count-rest-two #(1 2 3 4) 1 3)
#+END_SRC

#+RESULTS:
: 1

最后左右指针相遇时，指针下的数可能刚好和前一个相同，如果用小于判断出循环，结果就不对了。

考虑到计算完在双指针中间可能还有解，为了把这个函数用在最后的，需要在最后把双指针最后的位置也返回出来，稍作修改：

#+BEGIN_SRC scheme :session
(use-modules (srfi srfi-11))

(define (count-rest-two arr left right)
  (let ((a (vector-ref arr left))
        (b (vector-ref arr right)))
    (let loop ((start (+ left 1))
               (end (- right 1))
               (l-count 1)
               (r-count 1))
      (if (<= start end)
          (cond
           ((eq? a (vector-ref arr start))
            (loop (+ start 1)
                  end
                  (+ l-count 1)
                  r-count))
           ((eq? b (vector-ref arr end))
            (loop start
                  (- end 1)
                  l-count
                  (+ r-count 1)))
           (else (values start end (* l-count r-count))))
          (values start end (* l-count r-count))))))

(define (three-sum-multi arr target)
  (let ((len (vector-length arr))
        (sorted (sort arr <)))
    (let outer-loop ((i 0)
                     (ans 0))
      (if (< i (- len 2))
          (let loop ((left (+ i 1))
                     (right (- len 1))
                     (ans ans))
            (if (< left right)
                (let ((sum (+ (vector-ref sorted i)
                              (vector-ref sorted left)
                              (vector-ref sorted right))))
                  (cond
                   ((> sum target) (loop left (- right 1) ans))
                   ((< sum target) (loop (+ left 1) right ans))
                   (else
                    ;; 排序后首尾相同，说明中间全是一样的数
                    (if (eq? (vector-ref sorted left)
                             (vector-ref sorted right))
                        (let ((count (+ (- right left) 1)))
                          (outer-loop (+ i 1)
                                      (+ ans
                                         (quotient (* count (- count 1)) 2))))
                        (let-values (((new-left new-right new-count) (count-rest-two sorted left right)))
                          (loop new-left
                                new-right
                                (+ ans new-count)))))))
                (outer-loop (+ i 1) ans)))
          (modulo ans MOD)))))
#+END_SRC

#+RESULTS:
: #<unspecified>

测试：

#+BEGIN_SRC scheme :session
(three-sum-multi #(1 1 2 2 3 3 4 4 5 5) 8)
#+END_SRC

#+RESULTS:
: 20

#+BEGIN_SRC scheme :session
(three-sum-multi #(1 1 2 2 2 2) 5)
#+END_SRC

#+RESULTS:
: 12

#+BEGIN_SRC scheme :session
(three-sum-multi #(2 1 3) 6)
#+END_SRC

#+RESULTS:
: 1

* [[https://leetcode.cn/problems/valid-triangle-number/description/][611. 有效三角形的个数]]

两边和大于第三边
排序，固定最小边sorted[i]，最大边从sorted[i + 2]到sorted[n]，找中间边

#+BEGIN_SRC scheme :session
(define (triangle-number nums)
  (let ((len (vector-length nums))
        (sorted (sort nums <)))
    (let i-loop ((i 0)
                 (ans 0))
      (if (< i (- len 2))
          (if (= (vector-ref sorted i) 0)
              (i-loop (+ i 1) ans)
              (let k-loop ((k (+ i 2))
                           (ans ans))
                (if (< k len)
                    (let j-loop ((j (+ i 1)))
                      (if (< j k)
                          (let ((short (+ (vector-ref sorted i)
                                          (vector-ref sorted j)))
                                (long (vector-ref sorted k)))
                            (if (> short long)
                                (k-loop (+ k 1)
                                        (+ ans (- k j)))
                                (j-loop (+ j 1))))
                          (k-loop (+ k 1)
                                  ans)))
                    (i-loop (+ i 1)
                            ans))))
          ans))))
#+END_SRC

#+RESULTS:
: #<unspecified>

测试：

#+BEGIN_SRC scheme :session
(triangle-number #(2 2 3 4))
#+END_SRC

#+RESULTS:
: 3

#+BEGIN_SRC scheme :session
(triangle-number #(4 2 3 4))
#+END_SRC

#+RESULTS:
: 4

#+BEGIN_SRC scheme :session
(triangle-number #(0))
#+END_SRC

#+RESULTS:
: 0

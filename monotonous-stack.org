#+TITLE: 單調棧

* [[https://leetcode.cn/problems/daily-temperatures/description/][739. 每日温度]]

從右往左，入棧，棧不爲空且棧頂比當前大，更新答案爲棧頂索引減當前索引，否則出棧；棧空，說明後面沒有比當前大的數，答案記入0。

#+BEGIN_SRC scheme :session
(define (daily-temperatures temperatures)
  (let ((len (vector-length temperatures)))
    (let loop ((i (- len 1))
               (stack '())
               (ans '()))
      (if (> i -1)
          (let ((cur (vector-ref temperatures i)))
            (if (null? stack)
                (loop (- i 1)
                      (cons i stack)
                      (cons 0 ans))
                (if (>= cur (vector-ref temperatures (car stack)))
                    (loop i
                          (cdr stack)
                          ans)
                    (loop (- i 1)
                          (cons i stack)
                          (cons (- (car stack) i)
                                ans)))))
          ans))))
#+END_SRC

#+RESULTS:
: #<unspecified>

測試：

#+BEGIN_SRC scheme :session
(daily-temperatures #(73 74 75 71 69 72 76 73))
#+END_SRC

#+RESULTS:
| 1 | 1 | 4 | 2 | 1 | 1 | 0 | 0 |

** Python寫法

*** 從右往左

#+BEGIN_SRC python
def daily_temperatures(temperatures):
    n = len(temperatures)
    stack = []
    ans = [0] * n
    for i in range(n - 1, -1, -1):
        t = temperatures[i]
        while stack and t >= temperatures[stack[-1]]:
            stack.pop()
        if stack:
            ans[i] = stack[-1] - i
        stack.append(i)
    return ans
#+END_SRC

*** 從左往右

#+BEGIN_SRC python
def daily_temperatures(temperatures):
    n = len(temperatures)
    stack = []
    ans = [0] * n
    for i, t in enumerate(temperatures):
        while stack and t > temperatures[stack[-1]]:
            smaller_i = stack.pop()
            ans[smaller_i] = i - smaller_i
        stack.append(i)
    return ans
#+END_SRC

* [[https://leetcode.cn/problems/final-prices-with-a-special-discount-in-a-shop/description/][1475. 商品折扣后的最终价格]]

#+BEGIN_SRC scheme :session
(define (final-prices prices)
  (let ((len (vector-length prices))
        (i 0)
        (stack '())
        (ans (vector-copy prices)))
    (while (< i len)
      (let ((cur (vector-ref prices i)))
        (while (and (not (null? stack))
                    (>= (vector-ref prices (car stack)) cur))
          (vector-set! ans
                       (car stack)
                       (- (vector-ref ans (car stack))
                          cur))
          (set! stack (cdr stack))))
      (set! stack (cons i stack))
      (set! i (+ 1 i)))
    ans))
#+END_SRC

#+RESULTS:
: #<unspecified>

測試：

#+BEGIN_SRC scheme :session
(final-prices #(8 4 6 2 3))
#+END_SRC

#+RESULTS:
: #(4 2 4 2 3)

從右往左（提交LeetCode，返回list）：

#+BEGIN_SRC scheme :session
(define (final-prices prices)
  (let ((len (vector-length prices)))
    (let loop ((i (- len 1))
               (stack '(0))
               (ans '()))
      (if (> i -1)
          (let ((cur (vector-ref prices i)))
            (if (and (not (null? stack))
                     (> (car stack) cur))
                (loop i
                      (cdr stack)
                      ans)
                (loop (- i 1)
                      (cons cur stack)
                      (cons (- cur (car stack)) ans))))
          ans))))
#+END_SRC

#+RESULTS:
: #<unspecified>

測試：

#+BEGIN_SRC scheme :session
(final-prices #(8 4 6 2 3))
#+END_SRC

#+RESULTS:
| 4 | 2 | 4 | 2 | 3 |

#+BEGIN_SRC scheme :session
(final-prices #(10 1 1 6))
#+END_SRC

#+RESULTS:
| 9 | 0 | 1 | 6 |

* [[https://leetcode.cn/problems/next-greater-element-i/description/][496. 下一个更大元素 I]]

** Python解法

#+BEGIN_SRC python :session
def next_greater_element(nums1, nums2):
    index_map = { x: i for i, x in enumerate(nums1) }
    stack = []
    ans = [-1] * len(nums1)
    for x in nums2:
        while stack and x > stack[-1]:
            index = index_map[stack[-1]]
            ans[index] = x
            stack.pop()
        if x in nums1:
            stack.append(x)
    return ans
#+END_SRC

#+RESULTS:
: None

#+BEGIN_SRC python :session
next_greater_element([4, 1, 2], [1, 3, 4, 2])
#+END_SRC

#+RESULTS:
| -1 | 3 | -1 |

* [[https://leetcode.cn/problems/next-greater-element-ii/description/][503. 下一个更大元素 II]]

從右往左，n乘2，索引取模模擬循環數組：

#+BEGIN_SRC python :session
def next_greater_elements(nums):
    n = len(nums)
    stack = []
    ans = [-1] * n
    for i in range(n * 2 - 1, -1, -1):
        x = nums[i % n]
        while stack and x >= stack[-1]:
            stack.pop()
        if stack and i < n:
            ans[i] = stack[-1]
        stack.append(x)
    return ans
#+END_SRC

#+RESULTS:
: None

#+BEGIN_SRC python :session
next_greater_elements([1, 2, 1])
#+END_SRC

#+RESULTS:
| 2 | -1 | 2 |

#+BEGIN_SRC python :session
next_greater_elements([1, 2, 3, 4, 3])
#+END_SRC

#+RESULTS:
| 2 | 3 | 4 | -1 | 4 |

從左往右：

#+BEGIN_SRC python
def next_greater_elements(nums):
    n = len(nums)
    stack = []
    ans = [-1] * n
    for i in range(n * 2):
        x = nums[i % n]
        while stack and x > nums[stack[-1]]:
            ans[stack.pop()] = x
        if i < n:
            stack.append(i)
    return ans
#+END_SRC

* [[https://leetcode.cn/problems/online-stock-span/description/][901. 股票价格跨度]]

#+BEGIN_SRC python
class StockSpanner:
    def __init__(self):
        self.stack = [(-1, inf)]
        self.today = -1

    def next(self, price: int) -> int:
        while price >= self.stack[-1][1]:
            self.stack.pop()
        self.today += 1
        self.stack.append((self.today, price))
        return self.today - self.stack[-2][0]
#+END_SRC

* [[https://leetcode.cn/problems/car-fleet/description/][853. 车队]]

落後的車必需以更快的速度纔有可能追上前車

按當前位置排序，算不考慮其它車的情況下到終點的時間，(終點 - 當前位置) / 速度

位置靠後的車，如果需要的時間比前車多，是不是就會被追上？

問題就變成，找當前元素的上一個時間比當前大的元素，中間所有車都屬於一個車隊

#+BEGIN_SRC python
def car_fleet(target, position, speed):
    # zip後按position排序
    cars = sorted(zip(position, speed))
    # 這裏用單調棧，棧深度表示的就是車隊數
    stack = []
    for p, s in cars:
        time = (target - p) / s
        while stack and stack[-1] <= time:
            stack.pop()
        stack.append(time)
    return len(stack)
#+END_SRC

* [[https://leetcode.cn/problems/next-greater-node-in-linked-list/description/][1019. 链表中的下一个更大节点]]

輸入是列表，輸出是數組，需要維護索引。

#+BEGIN_SRC python
def next_larger_nodes(head):
    stack = []
    i = 0
    ans = []
    while head:
        x = head.val
        while stack and x > stack[-1][0]:
            ans[stack.pop()[1]] = x
        stack.append([x, i])
        i += 1
        ans.append(0)
        head = head.next
    return ans
#+END_SRC

直接將當前值推入ans，stack存當前索引：

#+BEGIN_SRC python
def next_larger_nodes(head):
    stack = []
    ans = []
    while head:
        x = head.val
        while stack and x > ans[stack[-1]]:
            ans[stack.pop()] = x
        stack.append(len(ans))
        ans.append(x)
        head = head.next
    for i in stack:
        ans[i] = 0
    return ans
#+END_SRC

* [[https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/][768. 最多能完成排序的块 II]]

每遇到一个更大的数就应该单独分一块。

但是遇到更小的数，也不能忽略，如[4, 5, 3]，到5的时候可以分成两块，但是到3时，3比上一个块里最大的数还小，得重新分配块。

用一个栈结构存每个块的最大值，遇到大数就入栈，小数就和之前的块最大值比较，比以前的块最大值小就要减少一个块划分。最后栈深度就是最大块数。

题目要求array，但racket给的是list

#+BEGIN_SRC scheme :session
(use-modules (ice-9 match))

(define (max-chunks-to-sorted arr)
  (let loop ((lst arr)
             (blocks '()))
    (match lst
      (() (length blocks))
      ((x xs ...) (if (or (null? blocks)
                          (>= x (car blocks)))
                       (loop xs
                             (cons x blocks))
                       (let ((top (car blocks))
                             (re-splitted (let re-split ((b (cdr blocks)))
                                            (if (and (not (null? b))
                                                     (> (car b) x))
                                                (re-split (cdr b))
                                                b))))
                         (loop xs
                               (cons top re-splitted))))))))
#+END_SRC

#+RESULTS:
: #<unspecified>

#+BEGIN_SRC scheme :session
(max-chunks-to-sorted '(5 4 3 2 1))
#+END_SRC

#+RESULTS:
: 1

#+BEGIN_SRC scheme :session
(max-chunks-to-sorted '(2 1 3 4 4))
#+END_SRC

#+RESULTS:
: 4

* [[https://leetcode.cn/problems/132-pattern/description/][456. 132 模式]]

#+BEGIN_SRC scheme :session
(use-modules (srfi srfi-11))

(define (find132pattern nums)
  (let ((len (vector-length nums)))
    (let loop ((i (- len 1))
               (stack '())
               (k -inf.0))
      (if (< i 0)
          #f
          (let ((cur (vector-ref nums i)))
            (if (< cur k)
                #t
                (let-values (((new-stack new-k)
                              (let pop-loop ((st stack) (cur-k k))
                                (if (and (not (null? st))
                                         (< (car st) cur))
                                    (pop-loop (cdr st)
                                              (max cur-k (car st)))
                                    (values st cur-k)))))
                  (loop (- i 1)
                        (cons cur new-stack)
                        new-k))))))))
#+END_SRC

#+RESULTS:
: #<unspecified>

测试：

#+BEGIN_SRC scheme :session
(find132pattern #(1 2 3 4))
#+END_SRC

#+RESULTS:
: #f

#+BEGIN_SRC scheme :session
(find132pattern #(3 1 4 2))
#+END_SRC

#+RESULTS:
: #t

* [[https://leetcode.cn/problems/find-the-number-of-subarrays-where-boundary-elements-are-maximum/][3113. 边界元素是最大值的子数组数目]]

两端相等中间小，且答案至少是数组长度

遍历，遇到大的出栈？

#+BEGIN_SRC scheme :session
(define (number-of-subarrays nums)
  (let ((n (vector-length nums)))
    (let loop ((i 0)
               (stack '())
               (ans n))
      (if (< i n)
          (let ((cur (vector-ref nums i)))
            (if (null? stack)
                (loop (+ i 1)
                      (cons cur stack)
                      ans)
                (let ((top (car stack)))
                  (cond
                   ((= cur top) (loop (+ i 1)
                                      stack
                                      (+ ans 1)))
                   ((> cur top) (loop i
                                      (cdr stack)
                                      ans))
                   (else (loop (+ i 1)
                               stack
                               ans))))))
          ans))))
#+END_SRC

#+RESULTS:
: #<unspecified>

#+BEGIN_SRC scheme :session
(number-of-subarrays #(1 4 3 3 2)) ;; 答案应为6
#+END_SRC

#+RESULTS:
: 5

结果不对

遇到大于栈顶出栈没错，但是遇到小的应该也进栈

#+BEGIN_SRC scheme :session
(define (number-of-subarrays nums)
  (let ((n (vector-length nums)))
    (let loop ((i 0)
               (stack '())
               (ans n))
      (if (< i n)
          (let ((cur (vector-ref nums i)))
            (if (null? stack)
                (loop (+ i 1)
                      (cons cur stack)
                      ans)
                (let ((top (car stack)))
                  (cond
                   ((= cur top) (loop (+ i 1)
                                      stack
                                      (+ ans 1)))
                   ((> cur top) (loop i
                                      (cdr stack)
                                      ans))
                   (else (loop (+ i 1)
                               (cons cur stack)
                               ans))))))
          ans))))
#+END_SRC

#+RESULTS:
: #<unspecified>

测试：

#+BEGIN_SRC scheme :session
(number-of-subarrays #(1 4 3 3 2)) ;; 答案应为6
#+END_SRC

#+RESULTS:
: 6

#+BEGIN_SRC scheme :session
(number-of-subarrays #(3 3 3)) ;; 答案应为6
#+END_SRC

#+RESULTS:
: 5

输入为 =#(3 3 3)= 时不对，前两个3，后两个3，首尾两个3有3种组合

n个相等的数，中间都符合条件，那就有n种组合，栈里还需要保留计数

#+BEGIN_SRC scheme :session
(define (number-of-subarrays nums)
  (let ((n (vector-length nums)))
    (let loop ((i 0)
               (stack '())
               (ans n))
      (if (< i n)
          (let ((cur (vector-ref nums i)))
            (if (null? stack)
                (loop (+ i 1)
                      (cons (cons cur 1) stack)
                      ans)
                (let ((top (caar stack))
                      (top-cnt (cdar stack)))
                  (cond
                   ((= cur top) (loop (+ i 1)
                                      (cons (cons top (+ top-cnt 1))
                                            (cdr stack))
                                      (+ ans top-cnt)))
                   ((> cur top) (loop i
                                      (cdr stack)
                                      ans))
                   (else (loop (+ i 1)
                               (cons (cons cur 1) stack)
                               ans))))))
          ans))))
#+END_SRC

#+RESULTS:
: #<unspecified>

#+BEGIN_SRC scheme :session
(number-of-subarrays #(1 4 3 3 2)) ;; 答案应为6
#+END_SRC

#+RESULTS:
: 6

#+BEGIN_SRC scheme :session
(number-of-subarrays #(3 3 3)) ;; 答案应为6
#+END_SRC

#+RESULTS:
: 6

* [[https://leetcode.cn/problems/beautiful-towers-i/description/][2865. 美丽塔 I]]

** 暴力做法

#+BEGIN_SRC scheme :session
(define (maximum-sum-of-heights heights)
  (let ((n (vector-length heights)))
    (define (calculate-sum i)
      (let* ((current-height (vector-ref heights i))
             ;; 计算左侧部分的和
             (left-sum (let loop ((j (- i 1))
                                  (pre current-height)
                                  (sum 0))
                         (if (< j 0)
                             sum
                             (let ((new-pre (min pre (vector-ref heights j))))
                               (loop (- j 1)
                                     new-pre
                                     (+ sum new-pre))))))
             ;; 计算右侧部分的和
             (right-sum (let loop ((j (+ i 1))
                                   (suf current-height)
                                   (sum 0))
                          (if (>= j n)
                              sum
                              (let ((new-suf (min suf (vector-ref heights j))))
                                (loop (+ j 1)
                                      new-suf
                                      (+ sum new-suf)))))))
        (+ current-height left-sum right-sum)))
    
    ;; 遍历所有位置，找出最大和
    (let loop ((i 0)
               (res 0))
      (if (>= i n)
          res
          (loop (+ i 1)
                (max res (calculate-sum i)))))))
#+END_SRC

#+RESULTS:
: #<unspecified>

测试：

#+BEGIN_SRC scheme :session
(maximum-sum-of-heights #(5 3 4 1 1))
#+END_SRC

#+RESULTS:
: 13

#+BEGIN_SRC scheme :session
(maximum-sum-of-heights #(6 5 3 9 2 7))
#+END_SRC

#+RESULTS:
: 22

** 单调栈做法

空间换时间：

#+BEGIN_SRC scheme :session
(define (maximum-sum-of-heights max-heights)
  (let* ((n (vector-length max-heights))
         (prefix (make-vector n 0))
         (suffix (make-vector n 0)))
    
    ;; 计算前缀和，使用单调栈
    (let loop-prefix ((i 0)
                      (stack '()))
      (when (< i n)
        (let* ((current-height (vector-ref max-heights i))
               ;; 弹出栈中高度大于等于当前高度的元素
               (new-stack (let pop-loop ((s stack))
                           (if (or (null? s)
                                   (>= current-height 
                                      (vector-ref max-heights (car s))))
                               s
                               (pop-loop (cdr s)))))
               ;; 计算前缀和
               (prefix-val (if (null? new-stack)
                               (* (+ i 1) current-height)
                               (let ((last (car new-stack)))
                                 (+ (vector-ref prefix last)
                                    (* (- i last) current-height))))))
          (vector-set! prefix i prefix-val)
          (loop-prefix (+ i 1) (cons i new-stack)))))
    
    ;; 计算后缀和，使用单调栈，同时计算最大值
    (let loop-suffix ((i (- n 1))
                      (stack '())
                      (res 0))
      (if (< i 0)
          res
          (let* ((current-height (vector-ref max-heights i))
                 ;; 弹出栈中高度大于等于当前高度的元素
                 (new-stack (let pop-loop ((s stack))
                             (if (or (null? s)
                                     (>= current-height 
                                        (vector-ref max-heights (car s))))
                                 s
                                 (pop-loop (cdr s)))))
                 ;; 计算后缀和
                 (suffix-val (if (null? new-stack)
                                 (* (- n i) current-height)
                                 (let ((last (car new-stack)))
                                   (+ (vector-ref suffix last)
                                      (* (- last i) current-height)))))
                 ;; 更新最大值
                 (total (+ (vector-ref prefix i)
                          suffix-val
                          (- current-height)))
                 (new-res (max res total)))
            (vector-set! suffix i suffix-val)
            (loop-suffix (- i 1) (cons i new-stack) new-res))))))
#+END_SRC

#+RESULTS:
: #<unspecified>

测试：

#+BEGIN_SRC scheme :session
(maximum-sum-of-heights #(5 3 4 1 1))
#+END_SRC

#+RESULTS:
: 13

#+BEGIN_SRC scheme :session
(maximum-sum-of-heights #(6 5 3 9 2 7))
#+END_SRC

#+RESULTS:
: 22

暴力解47ms，单调栈3ms

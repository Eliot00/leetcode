#+TITLE: 單調棧

* [[https://leetcode.cn/problems/daily-temperatures/description/][739. 每日温度]]

從右往左，入棧，棧不爲空且棧頂比當前大，更新答案爲棧頂索引減當前索引，否則出棧；棧空，說明後面沒有比當前大的數，答案記入0。

#+BEGIN_SRC scheme :session
(define (daily-temperatures temperatures)
  (let ((len (vector-length temperatures)))
    (let loop ((i (- len 1))
               (stack '())
               (ans '()))
      (if (> i -1)
          (let ((cur (vector-ref temperatures i)))
            (if (null? stack)
                (loop (- i 1)
                      (cons i stack)
                      (cons 0 ans))
                (if (>= cur (vector-ref temperatures (car stack)))
                    (loop i
                          (cdr stack)
                          ans)
                    (loop (- i 1)
                          (cons i stack)
                          (cons (- (car stack) i)
                                ans)))))
          ans))))
#+END_SRC

#+RESULTS:
: #<unspecified>

測試：

#+BEGIN_SRC scheme :session
(daily-temperatures #(73 74 75 71 69 72 76 73))
#+END_SRC

#+RESULTS:
| 1 | 1 | 4 | 2 | 1 | 1 | 0 | 0 |

** Python寫法

*** 從右往左

#+BEGIN_SRC python
def daily_temperatures(temperatures):
    n = len(temperatures)
    stack = []
    ans = [0] * n
    for i in range(n - 1, -1, -1):
        t = temperatures[i]
        while stack and t >= temperatures[stack[-1]]:
            stack.pop()
        if stack:
            ans[i] = stack[-1] - i
        stack.append(i)
    return ans
#+END_SRC

*** 從左往右

#+BEGIN_SRC python
def daily_temperatures(temperatures):
    n = len(temperatures)
    stack = []
    ans = [0] * n
    for i, t in enumerate(temperatures):
        while stack and t > temperatures[stack[-1]]:
            smaller_i = stack.pop()
            ans[smaller_i] = i - smaller_i
        stack.append(i)
    return ans
#+END_SRC

* [[https://leetcode.cn/problems/final-prices-with-a-special-discount-in-a-shop/description/][1475. 商品折扣后的最终价格]]

#+BEGIN_SRC scheme :session
(define (final-prices prices)
  (let ((len (vector-length prices))
        (i 0)
        (stack '())
        (ans (vector-copy prices)))
    (while (< i len)
      (let ((cur (vector-ref prices i)))
        (while (and (not (null? stack))
                    (>= (vector-ref prices (car stack)) cur))
          (vector-set! ans
                       (car stack)
                       (- (vector-ref ans (car stack))
                          cur))
          (set! stack (cdr stack))))
      (set! stack (cons i stack))
      (set! i (+ 1 i)))
    ans))
#+END_SRC

#+RESULTS:
: #<unspecified>

測試：

#+BEGIN_SRC scheme :session
(final-prices #(8 4 6 2 3))
#+END_SRC

#+RESULTS:
: #(4 2 4 2 3)

從右往左（提交LeetCode，返回list）：

#+BEGIN_SRC scheme :session
(define (final-prices prices)
  (let ((len (vector-length prices)))
    (let loop ((i (- len 1))
               (stack '(0))
               (ans '()))
      (if (> i -1)
          (let ((cur (vector-ref prices i)))
            (if (and (not (null? stack))
                     (> (car stack) cur))
                (loop i
                      (cdr stack)
                      ans)
                (loop (- i 1)
                      (cons cur stack)
                      (cons (- cur (car stack)) ans))))
          ans))))
#+END_SRC

#+RESULTS:
: #<unspecified>

測試：

#+BEGIN_SRC scheme :session
(final-prices #(8 4 6 2 3))
#+END_SRC

#+RESULTS:
| 4 | 2 | 4 | 2 | 3 |

#+BEGIN_SRC scheme :session
(final-prices #(10 1 1 6))
#+END_SRC

#+RESULTS:
| 9 | 0 | 1 | 6 |

* [[https://leetcode.cn/problems/next-greater-element-i/description/][496. 下一个更大元素 I]]

** Python解法

#+BEGIN_SRC python :session
def next_greater_element(nums1, nums2):
    index_map = { x: i for i, x in enumerate(nums1) }
    stack = []
    ans = [-1] * len(nums1)
    for x in nums2:
        while stack and x > stack[-1]:
            index = index_map[stack[-1]]
            ans[index] = x
            stack.pop()
        if x in nums1:
            stack.append(x)
    return ans
#+END_SRC

#+RESULTS:
: None

#+BEGIN_SRC python :session
next_greater_element([4, 1, 2], [1, 3, 4, 2])
#+END_SRC

#+RESULTS:
| -1 | 3 | -1 |

* [[https://leetcode.cn/problems/next-greater-element-ii/description/][503. 下一个更大元素 II]]

從右往左，n乘2，索引取模模擬循環數組：

#+BEGIN_SRC python :session
def next_greater_elements(nums):
    n = len(nums)
    stack = []
    ans = [-1] * n
    for i in range(n * 2 - 1, -1, -1):
        x = nums[i % n]
        while stack and x >= stack[-1]:
            stack.pop()
        if stack and i < n:
            ans[i] = stack[-1]
        stack.append(x)
    return ans
#+END_SRC

#+RESULTS:
: None

#+BEGIN_SRC python :session
next_greater_elements([1, 2, 1])
#+END_SRC

#+RESULTS:
| 2 | -1 | 2 |

#+BEGIN_SRC python :session
next_greater_elements([1, 2, 3, 4, 3])
#+END_SRC

#+RESULTS:
| 2 | 3 | 4 | -1 | 4 |

從左往右：

#+BEGIN_SRC python
def next_greater_elements(nums):
    n = len(nums)
    stack = []
    ans = [-1] * n
    for i in range(n * 2):
        x = nums[i % n]
        while stack and x > nums[stack[-1]]:
            ans[stack.pop()] = x
        if i < n:
            stack.append(i)
    return ans
#+END_SRC

* [[https://leetcode.cn/problems/online-stock-span/description/][901. 股票价格跨度]]

#+BEGIN_SRC python
class StockSpanner:
    def __init__(self):
        self.stack = [(-1, inf)]
        self.today = -1

    def next(self, price: int) -> int:
        while price >= self.stack[-1][1]:
            self.stack.pop()
        self.today += 1
        self.stack.append((self.today, price))
        return self.today - self.stack[-2][0]
#+END_SRC

#+TITLE: 二分算法

#+BEGIN_SRC scheme :session
(add-to-load-path ".")

(use-modules (helper test))
#+END_SRC

#+RESULTS:
: #<unspecified>

* [[https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/][34. 在排序数组中查找元素的第一个和最后一个位置]]

** 思路
既然是排序數組，找最後一個位置就可以轉換爲找第一個大於target的數，結果減一就是最後一個位置了。

** 代碼

#+BEGIN_SRC scheme :session
(define (search-range nums target)
  (let* ((len (vector-length nums))
         (init-left 0)
         (init-right (- len 1)))
    (define (search left right target)
      (if (<= left right)
          (let* ((mid (+ left (quotient (- right left) 2)))
                 (mid-val (vector-ref nums mid)))
            (if (>= mid-val target)
                (search left
                        (- mid 1)
                        target)
                (search (+ mid 1)
                        right
                        target)))
          left))
    (let ((start (search init-left init-right target)))
      (if (or (eq? start len)
              (not (eq? (vector-ref nums start)
                        target)))
          '(-1 -1)
          (let ((end (- (search init-left init-right (+ target 1)) 1)))
            (list start end))))))
#+END_SRC

#+RESULTS:
: #<unspecified>

測試：

#+BEGIN_SRC scheme :session
(test search-range
      '(((#(5 7 7 8 8 10) 8) . '(3 4))
        ((#(5 7 7 8 8 10) 6) . '(-1 -1))
        ((#() 0) . '(-1 -1))))

#+END_SRC

#+RESULTS:
: '(((#(5 7 7 8 8 10) 8) (quote (3 4)) (3 4)) ((#(5 7 7 8 8 10) 6) (quote (-1 -1)) (-1 -1)) ((#() 0) (quote (-1 -1)) (-1 -1)))

* [[https://leetcode.cn/problems/search-insert-position/description/][35. 搜索插入位置]]

** 代碼

#+BEGIN_SRC scheme :session
(define (search-insert nums target)
  (let ((len (vector-length nums)))
    (let search ((left 0)
                 (right (- len 1)))
      (if (<= left right)
          (let* ((mid (+ left (quotient (- right left) 2)))
                 (mid-val (vector-ref nums mid)))
            (if (< mid-val target)
                (search (+ mid 1)
                        right)
                (search left
                        (- mid 1))))
          left))))
#+END_SRC

#+RESULTS:
: #<unspecified>

測試：

#+BEGIN_SRC scheme :session
(search-insert #(1 3 5 6) 5)
#+END_SRC

#+RESULTS:
: 2

#+BEGIN_SRC scheme :session
(search-insert #(1 3 5 6) 2)
#+END_SRC

#+RESULTS:
: 1

#+BEGIN_SRC scheme :session
(search-insert #(1 3 5 6) 7)
#+END_SRC

#+RESULTS:
: 4

* [[https://leetcode.cn/problems/binary-search/description/][704. 二分查找]]

** 代碼

#+BEGIN_SRC scheme :session
(define (search nums target)
  (let ((len (vector-length nums)))
    (let loop ((left 0)
               (right (- len 1)))
      (if (<= left right)
          (let* ((mid (+ left (quotient (- right left) 2)))
                 (mid-val (vector-ref nums mid)))
            (cond
             ((< mid-val target) (loop (+ mid 1) right))
             ((> mid-val target) (loop left (- right 1)))
             (else mid)))
          -1))))
#+END_SRC

#+RESULTS:
: #<unspecified>

測試：

#+BEGIN_SRC scheme :session
(search #(-1 0 3 5 9 12) 2)
#+END_SRC

#+RESULTS:
: -1

* [[https://leetcode.cn/problems/find-smallest-letter-greater-than-target/description/][744. 寻找比目标字母大的最小字母]]

** 代碼

#+BEGIN_SRC scheme :session
(define (next-greatest-letter letters target)
  (let ((len (vector-length letters)))
    (if (char<=? (vector-ref letters (- len 1))
                 target)
        (vector-ref letters 0)
        (let search ((left 0)
                     (right (- len 1)))
          (if (< left right)
              (let* ((mid (+ left (quotient (- right left) 2)))
                     (mid-val (vector-ref letters mid)))
                (if (char>? mid-val target)
                    (search left mid)
                    (search (+ mid 1) right)))
              (vector-ref letters left))))))
#+END_SRC

#+RESULTS:
: #<unspecified>

測試：

#+BEGIN_SRC scheme :session
(next-greatest-letter #(#\c #\f #\j) #\j)
#+END_SRC

#+RESULTS:
: #\c

* [[https://leetcode.cn/problems/maximum-count-of-positive-integer-and-negative-integer/description/][2529. 正整数和负整数的最大计数]]

** 思路

找第一個大於等於0的數，這個數的左邊都是負數，這個數的索引等於負數數目；再找第一個大於0的數，這個數及其右邊的數都是正數，數組長減索引等於正數數量。

** 代碼

#+BEGIN_SRC scheme :session
(define (maximum-count nums)
  (let ((neg (lower-bound nums 0))
        (pos (- (vector-length nums)
                (lower-bound nums 1))))
    (max neg pos)))

(define (lower-bound nums target)
  (let ((len (vector-length nums)))
    (let search ((left 0)
                 (right (- len 1)))
      (if (<= left right)
          (let* ((mid (+ left (quotient (- right left) 2)))
                 (mid-val (vector-ref nums mid)))
            (if (>= mid-val target)
                (search left
                        (- mid 1))
                (search (+ mid 1)
                        right)))
          left))))
#+END_SRC

#+RESULTS:
: #<unspecified>

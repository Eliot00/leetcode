* 滑動窗口

#+BEGIN_SRC scheme :session
(load "test.scm")
#+END_SRC

#+RESULTS:
: #<unspecified>

** 定長窗口

*** [[https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/][1456. 定长子串中元音的最大数目]]

**** 思路
1. 判斷當前右指針指向的字符是否是元音，更新局部計數。如果窗口大小不足，右移指針，重複第1步
2. 更新答案 ~ans = max(ans, local_count)~
3. 左指針右移，更新局部計數（是元音，減一，否則不變）

**** 解

#+BEGIN_SRC scheme :session
(define (max-vowels s k)
  (define (vowel? c)
    (member c '(#\a #\e #\i #\o #\u)))

  (let loop ((ans 0)
             (vowel 0)
             (index 0))
    (if (< index (string-length s))
      (let* ((window-not-full? (< index (- k 1)))
             (current-vowel? (vowel? (string-ref s index)))
             (new-vowel (if current-vowel? (+ vowel 1) vowel)))
        (if window-not-full?
          (loop ans new-vowel (+ index 1))
          (loop
            (max ans new-vowel)
            (if (vowel? (string-ref s (+ (-  index k) 1))) (- new-vowel 1) new-vowel)
            (+ index 1))))
      ans)))
#+END_SRC

#+RESULTS:
: #<unspecified>

測試：

#+BEGIN_SRC scheme :session
(max-vowels "abciiidef" 3)
#+END_SRC

#+RESULTS:
: 3

**** 優化

k是子串長度，答案不可能超過子串長度，當答案等於k時提前退出

#+BEGIN_SRC scheme :session
(define (max-vowels-v2 s k)
  (define (vowel? c)
    (member c '(#\a #\e #\i #\o #\u)))

  (let loop ((ans 0)
             (vowel 0)
             (index 0))
    (if (< index (string-length s))
      (let* ((left (+ (- index k) 1))
             (window-not-full? (< left 0))
             (current-vowel? (vowel? (string-ref s index)))
             (new-vowel (if current-vowel? (+ vowel 1) vowel)))
        (if window-not-full?
          (loop ans new-vowel (+ index 1))
          (let ((new-ans (max ans new-vowel)))
            (if (eq? new-ans k)
                new-ans
                (loop new-ans
                      (if (vowel? (string-ref s left)) (- new-vowel 1) new-vowel)
                      (+ index 1))))))
      ans)))
#+END_SRC

#+RESULTS:
: #<unspecified>

測試：

#+BEGIN_SRC scheme :session :results table
(list (list "string" "k" "ans")
      (list "abciiidef" 3 (max-vowels-v2 "abciiidef" 3))
      (list "aeiou" 2 (max-vowels-v2 "aeiou" 2))
      (list "leetcode" 3 (max-vowels-v2 "leetcode" 3))
      (list "rhythms" 4 (max-vowels-v2 "rhythms" 4))
      (list "tryhard" 4 (max-vowels-v2 "tryhard" 4)))
#+END_SRC

#+RESULTS:
| string    | k | ans |
| abciiidef | 3 |   3 |
| aeiou     | 2 |   2 |
| leetcode  | 3 |   2 |
| rhythms   | 4 |   0 |
| tryhard   | 4 |   1 |

*** [[https://leetcode.cn/problems/maximum-average-subarray-i/][643. 子数组最大平均数 I]]

**** 思路

k是固定的，要求平均值最大，那麼實際上只要找出最大的和，最後再除以k算平均值就可以

**** 代碼

#+BEGIN_SRC scheme :session
(define (find-max-average nums k)
  (let loop ((max-sum -inf.0)
             (s 0)
             (i 0))
    (if (< i (vector-length nums))
        (let ((new-s (+ s (vector-ref nums i)))
              (window-not-full? (< i (- k 1))))
          (if window-not-full?
              (loop max-sum new-s (+ i 1)) ; 窗口未滿
              (loop
               (max max-sum new-s) ; 更新最大和
               (- new-s (vector-ref nums (+ (- i k) 1))) ; 左端點離開窗口
               (+ i 1)))) ; 右移窗口
      (/ max-sum k))))
#+END_SRC

#+RESULTS:
: #<unspecified>

測試：

#+BEGIN_SRC scheme :session :results table
(list (list "nums" "k" "ans")
      (list "(1,12,-5,-6,50,3)" 4 (find-max-average (vector 1 12 -5 -6 50 3) 4))
      (list "(5)" 1 (find-max-average (vector 5) 1))
      (list "(1,2,3,4,5)" 2 (find-max-average (vector 1 2 3 4 5) 2))
      (list "(0,1,1,3,3)" 4 (find-max-average (vector 0 1 1 3 3) 4))
      (list "(-1,-2,-3,-4,-5)" 3 (find-max-average (vector -1 -2 -3 -4 -5) 3))
      (list "(1,2,3,4,5,6,7,8,9,10)" 5 (find-max-average (vector 1 2 3 4 5 6 7 8 9 10) 5)))
#+END_SRC

#+RESULTS:
| nums                   | k |   ans |
| (1,12,-5,-6,50,3)      | 4 | 12.75 |
| (5)                    | 1 |   5.0 |
| (1,2,3,4,5)            | 2 |   4.5 |
| (0,1,1,3,3)            | 4 |   2.0 |
| (-1,-2,-3,-4,-5)       | 3 |  -2.0 |
| (1,2,3,4,5,6,7,8,9,10) | 5 |   8.0 |

*** [[https://leetcode.cn/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/][1343. 大小为 K 且平均值大于等于阈值的子数组数目]]

**** 思路
*入-更新-出*​三步走。可以不用每次算平均值，比較窗口和與threshold的k倍

**** 代碼

#+BEGIN_SRC scheme :session
(define (num-of-subarrays arr k threshold)
  (let ([k-threshold (* k threshold)])
    (let loop ([i 0]
               [sum 0]
               [ans 0])
      (if (< i (vector-length arr))
        (let ([pre-sum (+ sum (vector-ref arr i))])
          (if (< i (- k 1))
            (loop (+ i 1) pre-sum ans)
            (loop (+ i 1)
                  (- pre-sum (vector-ref arr (+ (- i k) 1)))
                  (if (< pre-sum k-threshold) ans (+ ans 1)))))
        ans))))
#+END_SRC

#+RESULTS:
: #<unspecified>

測試：

#+BEGIN_SRC scheme :session :results output
(display "Case 1: ")
(display (num-of-subarrays (vector 2 2 2 2 5 5 5 8) 3 4))
(newline)

(display "Case 2: ")
(display (num-of-subarrays (vector 11 13 17 23 29 31 7 5 2 3) 3 5))
(newline)
#+END_SRC

#+RESULTS:
: Case 1: 3
: Case 2: 6

*** [[https://leetcode.cn/problems/minimum-recolors-to-get-k-consecutive-black-blocks/][2379. 得到 K 个黑块的最少涂色次数]]

**** 思路
本質上是數窗口內字符‘W’的數量，找出最少的窗口。但是比較得最小不太方便，那麼就反過來，找出‘B’最多的窗口。

**** 代碼

#+BEGIN_SRC scheme :session
(define (minimum-recolors blocks k)
  (let loop ((max-b-count 0)
             (b-count     0)
             (i           0))
    (if (< i (string-length blocks))
        (let ((local-b-count (if (char=? (string-ref blocks i) #\B)
                                 (+ b-count 1)
                                 b-count)))
          (if (< i (- k 1))
              (loop max-b-count local-b-count (+ i 1))
              (loop (max max-b-count local-b-count)
                    (if (char=? (string-ref blocks (+ (- i k) 1)) #\B)
                        (- local-b-count 1)
                        local-b-count)
                    (+ i 1))))
        (- k max-b-count))))
#+END_SRC

#+RESULTS:
: #<unspecified>

測試：

#+BEGIN_SRC scheme :session :results table
(test minimum-recolors
      '((("WBBWWBBWBW" 7) . 3)
        (("WBWBBBW" 2) . 0)))
#+END_SRC

#+RESULTS:
| (WBBWWBBWBW 7) | 3 | 3 |
| (WBWBBBW 2)    | 0 | 0 |

*** [[https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/][1423. 可获得的最大点数]]

**** 思路
題目要求只能從數組開頭或末尾取，反過來想，就是要找一個大小爲n-k的定長窗口，窗口內數的和最小

**** 代碼

#+BEGIN_SRC scheme :session
(define (max-score cardPoints k)
  (let* ((len (length cardPoints))
         (m (- len k)))
    (let loop ((min-sum 0)
               (sum     0)
               (rest    cardPoints)
               (window  cardPoints)
               (right   0))
      (if (< right len)
          (if (< right m)
              ;; 構建窗口，先算出前m個和用於後續比較
              (loop (+ min-sum (car window))
                    (+ sum (car window))
                    rest
                    (cdr window)
                    (+ right 1))
              ;; 向右滑動窗口
              (let ((new-sum (- (+ sum (car window)) (car rest))))
                (loop (min min-sum new-sum)
                      new-sum
                      (cdr rest)
                      (cdr window)
                      (+ right 1))))
          (- (apply + cardPoints) min-sum)))))
#+END_SRC

#+RESULTS:
: #<unspecified>

測試：

#+BEGIN_SRC scheme :session :results table
(test max-score
      '((((1 2 3 4 5 6 1) 3) . 12)
        (((2 2 2) 2) . 4)
        (((9 7 7 9 7 7 9) 7) . 55)))
#+END_SRC

#+RESULTS:
| ((1 2 3 4 5 6 1) 3) | 12 | 12 |
| ((2 2 2) 2)         |  4 |  4 |
| ((9 7 7 9 7 7 9) 7) | 55 | 55 |

**** 思路二
所有可能的取法：
- 取前k個數
- 前k-1個加後1個
- 前k-2個加後2個
- ……
- 前2個加後k-2個
- 前1個加後k-1個
- 後k個

先求出前k個數的和，從i=1開始枚舉到i=k，每次將當前和增加 =cardPoints[n - i] - cardPoints[k - i]=

其實這也是滑動窗口，只是索引不是從小到大連續的

**** 代碼

#+BEGIN_SRC scheme :session
(define (max-score-v2 cardPoints k)
  ;; 索引操作比較多，cardPoints用vector
  (let ((n (vector-length cardPoints))
        (init-sum (let loop ((i 0)
                             (s 0))
                    (if (eq? i k)
                        s
                        (loop (+ i 1) (+ s (vector-ref cardPoints i)))))))
    (let loop ((i 1)
               (cur-sum init-sum)
               (max-sum init-sum))
      (if (> i k)
          max-sum
          (let ((new-sum (+ (- cur-sum (vector-ref cardPoints (- k i)))
                            (vector-ref cardPoints (- n i)))))
            (loop (+ i 1)
                  new-sum
                  (max max-sum new-sum)))))))
#+END_SRC

#+RESULTS:
: #<unspecified>

測試：

#+BEGIN_SRC scheme :session
(test max-score-v2
      '(((#(1 2 3 4 5 6 1) 3) . 12)
        ((#(2 2 2) 2) . 4)
        ((#(9 7 7 9 7 7 9) 7) . 55)))
#+END_SRC

#+RESULTS:
: '(((#(1 2 3 4 5 6 1) 3) 12 12) ((#(2 2 2) 2) 4 4) ((#(9 7 7 9 7 7 9) 7) 55 55))

*** [[https://leetcode.cn/problems/k-radius-subarray-averages/][2090. 半径为 k 的子数组平均值]]

**** 思路
理論上可以一次遍歷

答案的頭尾k個值都是-1，先構建出大小 =k * 2 + 1= 的窗口，右端點i前進更新答案第 =i - k= 位

**** 代碼

#+BEGIN_SRC scheme :session
(define (get-averages nums k)
  (let* ((len (vector-length nums))
         (win-size (+ (* k 2) 1))
         (ans (make-vector len -1)))
    (let loop ((index 0)
               (pre-sum 0))
      (if (< index len)
          (let ((sum (+ pre-sum (vector-ref nums index)))) ; 右側進窗口，記錄和
            (if (< index (* k 2))
                (loop (+ index 1) sum) ; 構建窗口
                (begin
                  (vector-set! ans (- index k) (/ sum win-size)) ; 更新答案
                  (loop (+ index 1)
                        ;; 出窗口
                        (- sum (vector-ref nums (- index (* k 2))))))))
          ans))))
#+END_SRC

#+RESULTS:
: #<unspecified>

測試：

#+BEGIN_SRC scheme :session :results output
(display (get-averages
          #(7 4 3 9 1 8 5 2 6) 3))
(newline)
(display (get-averages
          #(100000) 0))
(newline)
(display (get-averages
          #(8) 100000))
(newline)
#+END_SRC

#+RESULTS:
: #(-1 -1 -1 37/7 32/7 34/7 -1 -1 -1)
: #(100000)
: #(-1)

*** [[https://leetcode.cn/problems/minimum-discards-to-balance-inventory/description/][3679. 使库存平衡的最少丢弃次数]]

**** 思路
需要一個哈希表計數，題目設定是到時間如果貨物類型超了就必須丟棄，所以不能在出窗口時直接減計數，一種方法是另用一個哈希表記錄是否被丟棄，另一種方法是到達上限時將arrivals當前值置爲0，這樣後續出窗口只會去改0的計數，不影響結果，但是需要改變原始的arrivals，這裏用方法一。

**** 代碼

#+BEGIN_SRC scheme :session
(define (min-arrivals-to-discard arrivals w m)
  (let ((counter (make-hash-table)) ; 記錄每個類型貨物出現次數
        (discard (make-hash-table)) ; 記錄是否被丟棄
        (len (vector-length arrivals)))
    (let loop ((index 0)
               (ans 0))
      (if (< index len)
          (let* ((cur (vector-ref arrivals index))
                 (overflow? (eq? m (hash-ref counter cur))))
            (if overflow?
                (hash-set! discard index #t)
                (hash-set! counter
                           cur
                           (+ (hash-ref counter cur 0) 1)))
            (let ((left (+ (- index w) 1)))
              (when (and (not (hash-ref discard left)) ; 沒被丟棄過
                         (>= left 0)) ; 並且窗口已經展開（i - w + 1 > 0）
                ;; 出窗口，減計數
                (hash-set! counter
                           (vector-ref arrivals left)
                           (- (hash-ref counter (vector-ref arrivals left) 0) 1))))
            (loop (+ index 1) (if overflow? (+ ans 1) ans)))
          ans))))
#+END_SRC

#+RESULTS:
: #<unspecified>

測試：

#+BEGIN_SRC scheme :session
(test min-arrivals-to-discard
      '(((#(1 2 1 3 1) 4 2) . 0)
        ((#(1 2 3 3 3 4) 3 2). 1)))
#+END_SRC

#+RESULTS:
: '(((#(1 2 1 3 1) 4 2) 0 0) ((#(1 2 3 3 3 4) 3 2) 1 1))

*** [[https://leetcode.cn/problems/grumpy-bookstore-owner/description/][1052. 爱生气的书店老板]]
**** 思路
控制生氣的時間應該要留給顧客數最大的區間，但是老板不是每一分鐘都生氣，也許剛好人最多的區間沒有生氣

按滑動窗口的思路，維護minutes窗口，區間內顧客數加上區間外grumpy爲0的顧客數，取最大，但要想方法不能一直重複算區間外的顧客數

grumpy爲0時，顧客一定滿意，老板使用控制技能，在minutes內不生氣，只會使結果加上grumpy爲1對應的顧客數，那麼如果先算一遍grumpy爲0的顧客數，再滑動窗口，找出grumpy爲1的顧客數最多的窗口，加起來就得到結果。

**** 代碼

實作可以不用先遍歷一次求在不控制情緒情況下的顧客和，因爲只需要在最後用到這個值，在滑動窗口的同時累加就可以

#+BEGIN_SRC scheme :session
(define (max-satisfied customers grumpy minutes)
  (let ((len (vector-length customers)))
    (let loop ((origin-sum 0) ; 記錄不控制情緒情況下，滿意顧客數
               (extra-sum 0) ; 記錄控制情緒所能獲得的最大顧客數
               (s 0) ; 當前窗口通過控制情緒可以使其滿意的顧客數
               (i 0))
      (if (< i len)
          ;; 進窗口
          (let* ((angry? (eq? (vector-ref grumpy i) 1))
                 (current-customers (vector-ref customers i))
                 (new-origin-sum (+ origin-sum (if angry? 0 current-customers))) ; 如果沒生氣，更新origin-sum
                 (new-s (+ s (if angry? current-customers 0)))) ; 如果生氣，更新s
            (if (< i (- minutes 1))
                (loop new-origin-sum
                      new-s ; 窗口沒滿，還不用比較更新extra-sum，直接設成new-s
                      new-s
                      (+ i 1))
                (loop new-origin-sum
                      (max extra-sum new-s)
                      ;; 出窗口
                      (if (eq? (vector-ref grumpy (+ (- i minutes) 1)) 1)
                          (- new-s (vector-ref customers (+ (- i minutes) 1)))
                          new-s)
                      (+ i 1))))
          (+ origin-sum extra-sum)))))
#+END_SRC

#+RESULTS:
: #<unspecified>

*** [[https://leetcode.cn/problems/defuse-the-bomb/description/][1652. 拆炸弹]]

**** 思路

數組最長100，理論上可以直接暴力解

索引和k之間有個什麼聯繫，暫時不知道，先列出例子中所有的索引，試着找出關係

n = 4, k = 3:

| i | a | b | c |
|---+---+---+---|
| 0 | 1 | 2 | 3 |
| 1 | 2 | 3 | 0 |
| 2 | 3 | 0 | 1 |
| 3 | 0 | 1 | 2 |

看到循環數組，首先想到應該有模運算，可以發現， \(c = (i + k) \mod n\)
或者也可以把a到c看作一個滑動窗口，從左往右滑動排序後表格如下：

| window    | i（答案第i位） |
|-----------+----------------|
| (0, 1, 2) |              3 |
| (1, 2, 3) |              0 |
| (2, 3, 0) |              1 |
| (3, 0, 1) |              2 |

那在滑動過程中，能從右指針推出應該更新答案的第幾位嗎？可以的，按前面c也就是右指針和i的關係，做逆運算： \(i = (right - k) \mod n\)

再看看題目裏例子三k = -2的情況，是否有不同

n = 4, k = -2

k是負數，但是窗口長度（或寬度）肯定只能是2，還是一樣從左往右滑動

| window    | i（答案第i位） |
|-----------+----------------|
| (0, 1)    |              2 |
| (1, 2)    |              3 |
| (2, 3)    |              0 |
| (3, 0)    |              1 |

因爲題目規定k爲負數時，算當前索引前k個數的和，所以右指針加1就是索引，但注意不能溢出，還是需要模運算： \(i = (right + 1) \mod n\)

這樣一來問題就簡單了，除了k等於0時直接返回全0數組，其他情況只要維護一個長爲 =abs(k)= 的窗口，向右滑動，根據右端點索引和答案索引的關係，去更新相應的答案就可以了。

**** 代碼

#+BEGIN_SRC scheme :session
(define (decrypt code k)
  (let* ((n (vector-length code))
         (ans (make-vector n 0))
         (abs-k (abs k)))
    (if (eq? k 0)
        ans
        (let loop ((sum 0)
                   (right 0)
                   (left 0))
          (if (< left n)
              ;; 進窗口
              (let ((new-sum(+ sum (vector-ref code (modulo right n)))))
                (if (< right (- abs-k 1))
                    (loop new-sum
                          (+ right 1)
                          left) ; 先展開窗口
                    (begin
                      ;; 更新答案
                      (vector-set! ans
                                   (if (> k 0)
                                       (modulo (- right k) n)
                                       (modulo (+ right 1) n))
                                   new-sum)
                      ;; 出窗口
                      (loop (- new-sum (vector-ref code left))
                            (+ right 1)
                            (+ left 1)))))
              ans)))))
#+END_SRC

#+RESULTS:
: #<unspecified>

測試：

#+BEGIN_SRC scheme :session
(decrypt #(5 2 2 3 1) 3)
#+END_SRC

#+RESULTS:
: #(7 6 9 8 9)

* 滑動窗口

#+BEGIN_SRC scheme :session
(load "test.scm")
#+END_SRC

#+RESULTS:
: #<unspecified>

** 定長窗口

*** [[https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/][1456. 定长子串中元音的最大数目]]

**** 思路
1. 判斷當前右指針指向的字符是否是元音，更新局部計數。如果窗口大小不足，右移指針，重複第1步
2. 更新答案 ~ans = max(ans, local_count)~
3. 左指針右移，更新局部計數（是元音，減一，否則不變）

**** 解

#+BEGIN_SRC scheme :session
(define (max-vowels s k)
  (define (vowel? c)
    (member c '(#\a #\e #\i #\o #\u)))

  (let loop ((ans 0)
             (vowel 0)
             (index 0))
    (if (< index (string-length s))
      (let* ((window-not-full? (< index (- k 1)))
             (current-vowel? (vowel? (string-ref s index)))
             (new-vowel (if current-vowel? (+ vowel 1) vowel)))
        (if window-not-full?
          (loop ans new-vowel (+ index 1))
          (loop
            (max ans new-vowel)
            (if (vowel? (string-ref s (+ (-  index k) 1))) (- new-vowel 1) new-vowel)
            (+ index 1))))
      ans)))
#+END_SRC

#+RESULTS:
: #<unspecified>

測試：

#+BEGIN_SRC scheme :session
(max-vowels "abciiidef" 3)
#+END_SRC

#+RESULTS:
: 3

**** 優化

k是子串長度，答案不可能超過子串長度，當答案等於k時提前退出

#+BEGIN_SRC scheme :session
(define (max-vowels-v2 s k)
  (define (vowel? c)
    (member c '(#\a #\e #\i #\o #\u)))

  (let loop ((ans 0)
             (vowel 0)
             (index 0))
    (if (< index (string-length s))
      (let* ((left (+ (- index k) 1))
             (window-not-full? (< left 0))
             (current-vowel? (vowel? (string-ref s index)))
             (new-vowel (if current-vowel? (+ vowel 1) vowel)))
        (if window-not-full?
          (loop ans new-vowel (+ index 1))
          (let ((new-ans (max ans new-vowel)))
            (if (eq? new-ans k)
                new-ans
                (loop new-ans
                      (if (vowel? (string-ref s left)) (- new-vowel 1) new-vowel)
                      (+ index 1))))))
      ans)))
#+END_SRC

#+RESULTS:
: #<unspecified>

測試：

#+BEGIN_SRC scheme :session :results table
(list (list "string" "k" "ans")
      (list "abciiidef" 3 (max-vowels-v2 "abciiidef" 3))
      (list "aeiou" 2 (max-vowels-v2 "aeiou" 2))
      (list "leetcode" 3 (max-vowels-v2 "leetcode" 3))
      (list "rhythms" 4 (max-vowels-v2 "rhythms" 4))
      (list "tryhard" 4 (max-vowels-v2 "tryhard" 4)))
#+END_SRC

#+RESULTS:
| string    | k | ans |
| abciiidef | 3 |   3 |
| aeiou     | 2 |   2 |
| leetcode  | 3 |   2 |
| rhythms   | 4 |   0 |
| tryhard   | 4 |   1 |

*** [[https://leetcode.cn/problems/maximum-average-subarray-i/][643. 子数组最大平均数 I]]

**** 思路

k是固定的，要求平均值最大，那麼實際上只要找出最大的和，最後再除以k算平均值就可以

**** 代碼

#+BEGIN_SRC scheme :session
(define (find-max-average nums k)
  (let loop ((max-sum -inf.0)
             (s 0)
             (i 0))
    (if (< i (vector-length nums))
        (let ((new-s (+ s (vector-ref nums i)))
              (window-not-full? (< i (- k 1))))
          (if window-not-full?
              (loop max-sum new-s (+ i 1)) ; 窗口未滿
              (loop
               (max max-sum new-s) ; 更新最大和
               (- new-s (vector-ref nums (+ (- i k) 1))) ; 左端點離開窗口
               (+ i 1)))) ; 右移窗口
      (/ max-sum k))))
#+END_SRC

#+RESULTS:
: #<unspecified>

測試：

#+BEGIN_SRC scheme :session :results table
(list (list "nums" "k" "ans")
      (list "(1,12,-5,-6,50,3)" 4 (find-max-average (vector 1 12 -5 -6 50 3) 4))
      (list "(5)" 1 (find-max-average (vector 5) 1))
      (list "(1,2,3,4,5)" 2 (find-max-average (vector 1 2 3 4 5) 2))
      (list "(0,1,1,3,3)" 4 (find-max-average (vector 0 1 1 3 3) 4))
      (list "(-1,-2,-3,-4,-5)" 3 (find-max-average (vector -1 -2 -3 -4 -5) 3))
      (list "(1,2,3,4,5,6,7,8,9,10)" 5 (find-max-average (vector 1 2 3 4 5 6 7 8 9 10) 5)))
#+END_SRC

#+RESULTS:
| nums                   | k |   ans |
| (1,12,-5,-6,50,3)      | 4 | 12.75 |
| (5)                    | 1 |   5.0 |
| (1,2,3,4,5)            | 2 |   4.5 |
| (0,1,1,3,3)            | 4 |   2.0 |
| (-1,-2,-3,-4,-5)       | 3 |  -2.0 |
| (1,2,3,4,5,6,7,8,9,10) | 5 |   8.0 |

*** [[https://leetcode.cn/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/][1343. 大小为 K 且平均值大于等于阈值的子数组数目]]

**** 思路
*入-更新-出*​三步走。可以不用每次算平均值，比較窗口和與threshold的k倍

**** 代碼

#+BEGIN_SRC scheme :session
(define (num-of-subarrays arr k threshold)
  (let ([k-threshold (* k threshold)])
    (let loop ([i 0]
               [sum 0]
               [ans 0])
      (if (< i (vector-length arr))
        (let ([pre-sum (+ sum (vector-ref arr i))])
          (if (< i (- k 1))
            (loop (+ i 1) pre-sum ans)
            (loop (+ i 1)
                  (- pre-sum (vector-ref arr (+ (- i k) 1)))
                  (if (< pre-sum k-threshold) ans (+ ans 1)))))
        ans))))
#+END_SRC

#+RESULTS:
: #<unspecified>

測試：

#+BEGIN_SRC scheme :session :results output
(display "Case 1: ")
(display (num-of-subarrays (vector 2 2 2 2 5 5 5 8) 3 4))
(newline)

(display "Case 2: ")
(display (num-of-subarrays (vector 11 13 17 23 29 31 7 5 2 3) 3 5))
(newline)
#+END_SRC

#+RESULTS:
: Case 1: 3
: Case 2: 6

*** [[https://leetcode.cn/problems/minimum-recolors-to-get-k-consecutive-black-blocks/][2379. 得到 K 个黑块的最少涂色次数]]

**** 思路
本質上是數窗口內字符‘W’的數量，找出最少的窗口。但是比較得最小不太方便，那麼就反過來，找出‘B’最多的窗口。

**** 代碼

#+BEGIN_SRC scheme :session
(define (minimum-recolors blocks k)
  (let loop ((max-b-count 0)
             (b-count     0)
             (i           0))
    (if (< i (string-length blocks))
        (let ((local-b-count (if (char=? (string-ref blocks i) #\B)
                                 (+ b-count 1)
                                 b-count)))
          (if (< i (- k 1))
              (loop max-b-count local-b-count (+ i 1))
              (loop (max max-b-count local-b-count)
                    (if (char=? (string-ref blocks (+ (- i k) 1)) #\B)
                        (- local-b-count 1)
                        local-b-count)
                    (+ i 1))))
        (- k max-b-count))))
#+END_SRC

#+RESULTS:
: #<unspecified>

測試：

#+BEGIN_SRC scheme :session :results table
(test minimum-recolors
      '((("WBBWWBBWBW" 7) . 3)
        (("WBWBBBW" 2) . 0)))
#+END_SRC

#+RESULTS:
| (WBBWWBBWBW 7) | 3 | 3 |
| (WBWBBBW 2)    | 0 | 0 |

*** [[https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/][1423. 可获得的最大点数]]

**** 思路
題目要求只能從數組開頭或末尾取，反過來想，就是要找一個大小爲n-k的定長窗口，窗口內數的和最小

**** 代碼

#+BEGIN_SRC scheme :session
(define (max-score cardPoints k)
  (let* ((len (length cardPoints))
         (m (- len k)))
    (let loop ((min-sum 0)
               (sum     0)
               (rest    cardPoints)
               (window  cardPoints)
               (right   0))
      (if (< right len)
          (if (< right m)
              (loop (+ min-sum (car window))
                    (+ sum (car window))
                    rest
                    (cdr window)
                    (+ right 1))
              (let ((new-sum (- (+ sum (car window)) (car rest))))
                (loop (min min-sum new-sum)
                      new-sum
                      (cdr rest)
                      (cdr window)
                      (+ right 1))))
          (- (apply + cardPoints) min-sum)))))
#+END_SRC

#+RESULTS:
: #<unspecified>

測試：

#+BEGIN_SRC scheme :session
(test max-score
      '((((1 2 3 4 5 6 1) 3) . 12)
        (((2 2 2) 2) . 4)
        (((9 7 7 9 7 7 9) 7) . 55)))
#+END_SRC

#+RESULTS:
| ((1 2 3 4 5 6 1) 3) | 12 | 12 |
| ((2 2 2) 2)         |  4 |  4 |
| ((9 7 7 9 7 7 9) 7) | 55 | 55 |

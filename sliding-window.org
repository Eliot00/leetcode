* 滑動窗口

#+BEGIN_SRC scheme :session
(load "test.scm")
#+END_SRC

#+RESULTS:
: #<unspecified>

** 定長窗口

*** [[https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/][1456. 定长子串中元音的最大数目]]

**** 思路
1. 判斷當前右指針指向的字符是否是元音，更新局部計數。如果窗口大小不足，右移指針，重複第1步
2. 更新答案 ~ans = max(ans, local_count)~
3. 左指針右移，更新局部計數（是元音，減一，否則不變）

**** 解

#+BEGIN_SRC scheme :session
(define (max-vowels s k)
  (define (vowel? c)
    (member c '(#\a #\e #\i #\o #\u)))

  (let loop ((ans 0)
             (vowel 0)
             (index 0))
    (if (< index (string-length s))
      (let* ((window-not-full? (< index (- k 1)))
             (current-vowel? (vowel? (string-ref s index)))
             (new-vowel (if current-vowel? (+ vowel 1) vowel)))
        (if window-not-full?
          (loop ans new-vowel (+ index 1))
          (loop
            (max ans new-vowel)
            (if (vowel? (string-ref s (+ (-  index k) 1))) (- new-vowel 1) new-vowel)
            (+ index 1))))
      ans)))
#+END_SRC

#+RESULTS:
: #<unspecified>

測試：

#+BEGIN_SRC scheme :session
(max-vowels "abciiidef" 3)
#+END_SRC

#+RESULTS:
: 3

**** 優化

k是子串長度，答案不可能超過子串長度，當答案等於k時提前退出

#+BEGIN_SRC scheme :session
(define (max-vowels-v2 s k)
  (define (vowel? c)
    (member c '(#\a #\e #\i #\o #\u)))

  (let loop ((ans 0)
             (vowel 0)
             (index 0))
    (if (< index (string-length s))
      (let* ((left (+ (- index k) 1))
             (window-not-full? (< left 0))
             (current-vowel? (vowel? (string-ref s index)))
             (new-vowel (if current-vowel? (+ vowel 1) vowel)))
        (if window-not-full?
          (loop ans new-vowel (+ index 1))
          (let ((new-ans (max ans new-vowel)))
            (if (eq? new-ans k)
                new-ans
                (loop new-ans
                      (if (vowel? (string-ref s left)) (- new-vowel 1) new-vowel)
                      (+ index 1))))))
      ans)))
#+END_SRC

#+RESULTS:
: #<unspecified>

測試：

#+BEGIN_SRC scheme :session :results table
(list (list "string" "k" "ans")
      (list "abciiidef" 3 (max-vowels-v2 "abciiidef" 3))
      (list "aeiou" 2 (max-vowels-v2 "aeiou" 2))
      (list "leetcode" 3 (max-vowels-v2 "leetcode" 3))
      (list "rhythms" 4 (max-vowels-v2 "rhythms" 4))
      (list "tryhard" 4 (max-vowels-v2 "tryhard" 4)))
#+END_SRC

#+RESULTS:
| string    | k | ans |
| abciiidef | 3 |   3 |
| aeiou     | 2 |   2 |
| leetcode  | 3 |   2 |
| rhythms   | 4 |   0 |
| tryhard   | 4 |   1 |

*** [[https://leetcode.cn/problems/maximum-average-subarray-i/][643. 子数组最大平均数 I]]

**** 思路

k是固定的，要求平均值最大，那麼實際上只要找出最大的和，最後再除以k算平均值就可以

**** 代碼

#+BEGIN_SRC scheme :session
(define (find-max-average nums k)
  (let loop ((max-sum -inf.0)
             (s 0)
             (i 0))
    (if (< i (vector-length nums))
        (let ((new-s (+ s (vector-ref nums i)))
              (window-not-full? (< i (- k 1))))
          (if window-not-full?
              (loop max-sum new-s (+ i 1)) ; 窗口未滿
              (loop
               (max max-sum new-s) ; 更新最大和
               (- new-s (vector-ref nums (+ (- i k) 1))) ; 左端點離開窗口
               (+ i 1)))) ; 右移窗口
      (/ max-sum k))))
#+END_SRC

#+RESULTS:
: #<unspecified>

測試：

#+BEGIN_SRC scheme :session :results table
(list (list "nums" "k" "ans")
      (list "(1,12,-5,-6,50,3)" 4 (find-max-average (vector 1 12 -5 -6 50 3) 4))
      (list "(5)" 1 (find-max-average (vector 5) 1))
      (list "(1,2,3,4,5)" 2 (find-max-average (vector 1 2 3 4 5) 2))
      (list "(0,1,1,3,3)" 4 (find-max-average (vector 0 1 1 3 3) 4))
      (list "(-1,-2,-3,-4,-5)" 3 (find-max-average (vector -1 -2 -3 -4 -5) 3))
      (list "(1,2,3,4,5,6,7,8,9,10)" 5 (find-max-average (vector 1 2 3 4 5 6 7 8 9 10) 5)))
#+END_SRC

#+RESULTS:
| nums                   | k |   ans |
| (1,12,-5,-6,50,3)      | 4 | 12.75 |
| (5)                    | 1 |   5.0 |
| (1,2,3,4,5)            | 2 |   4.5 |
| (0,1,1,3,3)            | 4 |   2.0 |
| (-1,-2,-3,-4,-5)       | 3 |  -2.0 |
| (1,2,3,4,5,6,7,8,9,10) | 5 |   8.0 |

*** [[https://leetcode.cn/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/][1343. 大小为 K 且平均值大于等于阈值的子数组数目]]

**** 思路
*入-更新-出*​三步走。可以不用每次算平均值，比較窗口和與threshold的k倍

**** 代碼

#+BEGIN_SRC scheme :session
(define (num-of-subarrays arr k threshold)
  (let ([k-threshold (* k threshold)])
    (let loop ([i 0]
               [sum 0]
               [ans 0])
      (if (< i (vector-length arr))
        (let ([pre-sum (+ sum (vector-ref arr i))])
          (if (< i (- k 1))
            (loop (+ i 1) pre-sum ans)
            (loop (+ i 1)
                  (- pre-sum (vector-ref arr (+ (- i k) 1)))
                  (if (< pre-sum k-threshold) ans (+ ans 1)))))
        ans))))
#+END_SRC

#+RESULTS:
: #<unspecified>

測試：

#+BEGIN_SRC scheme :session :results output
(display "Case 1: ")
(display (num-of-subarrays (vector 2 2 2 2 5 5 5 8) 3 4))
(newline)

(display "Case 2: ")
(display (num-of-subarrays (vector 11 13 17 23 29 31 7 5 2 3) 3 5))
(newline)
#+END_SRC

#+RESULTS:
: Case 1: 3
: Case 2: 6

*** [[https://leetcode.cn/problems/minimum-recolors-to-get-k-consecutive-black-blocks/][2379. 得到 K 个黑块的最少涂色次数]]

**** 思路
本質上是數窗口內字符‘W’的數量，找出最少的窗口。但是比較得最小不太方便，那麼就反過來，找出‘B’最多的窗口。

**** 代碼

#+BEGIN_SRC scheme :session
(define (minimum-recolors blocks k)
  (let loop ((max-b-count 0)
             (b-count     0)
             (i           0))
    (if (< i (string-length blocks))
        (let ((local-b-count (if (char=? (string-ref blocks i) #\B)
                                 (+ b-count 1)
                                 b-count)))
          (if (< i (- k 1))
              (loop max-b-count local-b-count (+ i 1))
              (loop (max max-b-count local-b-count)
                    (if (char=? (string-ref blocks (+ (- i k) 1)) #\B)
                        (- local-b-count 1)
                        local-b-count)
                    (+ i 1))))
        (- k max-b-count))))
#+END_SRC

#+RESULTS:
: #<unspecified>

測試：

#+BEGIN_SRC scheme :session :results table
(test minimum-recolors
      '((("WBBWWBBWBW" 7) . 3)
        (("WBWBBBW" 2) . 0)))
#+END_SRC

#+RESULTS:
| (WBBWWBBWBW 7) | 3 | 3 |
| (WBWBBBW 2)    | 0 | 0 |

*** [[https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/][1423. 可获得的最大点数]]

**** 思路
題目要求只能從數組開頭或末尾取，反過來想，就是要找一個大小爲n-k的定長窗口，窗口內數的和最小

**** 代碼

#+BEGIN_SRC scheme :session
(define (max-score cardPoints k)
  (let* ((len (length cardPoints))
         (m (- len k)))
    (let loop ((min-sum 0)
               (sum     0)
               (rest    cardPoints)
               (window  cardPoints)
               (right   0))
      (if (< right len)
          (if (< right m)
              ;; 構建窗口，先算出前m個和用於後續比較
              (loop (+ min-sum (car window))
                    (+ sum (car window))
                    rest
                    (cdr window)
                    (+ right 1))
              ;; 向右滑動窗口
              (let ((new-sum (- (+ sum (car window)) (car rest))))
                (loop (min min-sum new-sum)
                      new-sum
                      (cdr rest)
                      (cdr window)
                      (+ right 1))))
          (- (apply + cardPoints) min-sum)))))
#+END_SRC

#+RESULTS:
: #<unspecified>

測試：

#+BEGIN_SRC scheme :session :results table
(test max-score
      '((((1 2 3 4 5 6 1) 3) . 12)
        (((2 2 2) 2) . 4)
        (((9 7 7 9 7 7 9) 7) . 55)))
#+END_SRC

#+RESULTS:
| ((1 2 3 4 5 6 1) 3) | 12 | 12 |
| ((2 2 2) 2)         |  4 |  4 |
| ((9 7 7 9 7 7 9) 7) | 55 | 55 |

**** 思路二
所有可能的取法：
- 取前k個數
- 前k-1個加後1個
- 前k-2個加後2個
- ……
- 前2個加後k-2個
- 前1個加後k-1個
- 後k個

先求出前k個數的和，從i=1開始枚舉到i=k，每次將當前和增加 =cardPoints[n - i] - cardPoints[k - i]=

其實這也是滑動窗口，只是索引不是從小到大連續的

**** 代碼

#+BEGIN_SRC scheme :session
(define (max-score-v2 cardPoints k)
  ;; 索引操作比較多，cardPoints用vector
  (let ((n (vector-length cardPoints))
        (init-sum (let loop ((i 0)
                             (s 0))
                    (if (eq? i k)
                        s
                        (loop (+ i 1) (+ s (vector-ref cardPoints i)))))))
    (let loop ((i 1)
               (cur-sum init-sum)
               (max-sum init-sum))
      (if (> i k)
          max-sum
          (let ((new-sum (+ (- cur-sum (vector-ref cardPoints (- k i)))
                            (vector-ref cardPoints (- n i)))))
            (loop (+ i 1)
                  new-sum
                  (max max-sum new-sum)))))))
#+END_SRC

#+RESULTS:
: #<unspecified>

測試：

#+BEGIN_SRC scheme :session
(test max-score-v2
      '(((#(1 2 3 4 5 6 1) 3) . 12)
        ((#(2 2 2) 2) . 4)
        ((#(9 7 7 9 7 7 9) 7) . 55)))
#+END_SRC

#+RESULTS:
: '(((#(1 2 3 4 5 6 1) 3) 12 12) ((#(2 2 2) 2) 4 4) ((#(9 7 7 9 7 7 9) 7) 55 55))

*** [[https://leetcode.cn/problems/k-radius-subarray-averages/][2090. 半径为 k 的子数组平均值]]

**** 思路
理論上可以一次遍歷

答案的頭尾k個值都是-1，先構建出大小 =k * 2 + 1= 的窗口，右端點i前進更新答案第 =i - k= 位

**** 代碼

#+BEGIN_SRC scheme :session
(define (get-averages nums k)
  (let* ((len (vector-length nums))
         (win-size (+ (* k 2) 1))
         (ans (make-vector len -1)))
    (let loop ((index 0)
               (pre-sum 0))
      (if (< index len)
          (let ((sum (+ pre-sum (vector-ref nums index)))) ; 右側進窗口，記錄和
            (if (< index (* k 2))
                (loop (+ index 1) sum) ; 構建窗口
                (begin
                  (vector-set! ans (- index k) (/ sum win-size)) ; 更新答案
                  (loop (+ index 1)
                        ;; 出窗口
                        (- sum (vector-ref nums (- index (* k 2))))))))
          ans))))
#+END_SRC

#+RESULTS:
: #<unspecified>

測試：

#+BEGIN_SRC scheme :session :results output
(display (get-averages
          #(7 4 3 9 1 8 5 2 6) 3))
(newline)
(display (get-averages
          #(100000) 0))
(newline)
(display (get-averages
          #(8) 100000))
(newline)
#+END_SRC

#+RESULTS:
: #(-1 -1 -1 37/7 32/7 34/7 -1 -1 -1)
: #(100000)
: #(-1)

*** [[https://leetcode.cn/problems/minimum-discards-to-balance-inventory/description/][3679. 使库存平衡的最少丢弃次数]]

**** 思路
需要一個哈希表計數，題目設定是到時間如果貨物類型超了就必須丟棄，所以不能在出窗口時直接減計數，一種方法是另用一個哈希表記錄是否被丟棄，另一種方法是到達上限時將arrivals當前值置爲0，這樣後續出窗口只會去改0的計數，不影響結果，但是需要改變原始的arrivals，這裏用方法一。

**** 代碼

#+BEGIN_SRC scheme :session
(define (min-arrivals-to-discard arrivals w m)
  (let ((counter (make-hash-table)) ; 記錄每個類型貨物出現次數
        (discard (make-hash-table)) ; 記錄是否被丟棄
        (len (vector-length arrivals)))
    (let loop ((index 0)
               (ans 0))
      (if (< index len)
          (let* ((cur (vector-ref arrivals index))
                 (overflow? (eq? m (hash-ref counter cur))))
            (if overflow?
                (hash-set! discard index #t)
                (hash-set! counter
                           cur
                           (+ (hash-ref counter cur 0) 1)))
            (let ((left (+ (- index w) 1)))
              (when (and (not (hash-ref discard left)) ; 沒被丟棄過
                         (>= left 0)) ; 並且窗口已經展開（i - w + 1 > 0）
                ;; 出窗口，減計數
                (hash-set! counter
                           (vector-ref arrivals left)
                           (- (hash-ref counter (vector-ref arrivals left) 0) 1))))
            (loop (+ index 1) (if overflow? (+ ans 1) ans)))
          ans))))
#+END_SRC

#+RESULTS:
: #<unspecified>

測試：

#+BEGIN_SRC scheme :session
(test min-arrivals-to-discard
      '(((#(1 2 1 3 1) 4 2) . 0)
        ((#(1 2 3 3 3 4) 3 2). 1)))
#+END_SRC

#+RESULTS:
: '(((#(1 2 1 3 1) 4 2) 0 0) ((#(1 2 3 3 3 4) 3 2) 1 1))

*** [[https://leetcode.cn/problems/grumpy-bookstore-owner/description/][1052. 爱生气的书店老板]]
**** 思路
控制生氣的時間應該要留給顧客數最大的區間，但是老板不是每一分鐘都生氣，也許剛好人最多的區間沒有生氣

按滑動窗口的思路，維護minutes窗口，區間內顧客數加上區間外grumpy爲0的顧客數，取最大，但要想方法不能一直重複算區間外的顧客數

grumpy爲0時，顧客一定滿意，老板使用控制技能，在minutes內不生氣，只會使結果加上grumpy爲1對應的顧客數，那麼如果先算一遍grumpy爲0的顧客數，再滑動窗口，找出grumpy爲1的顧客數最多的窗口，加起來就得到結果。

**** 代碼

實作可以不用先遍歷一次求在不控制情緒情況下的顧客和，因爲只需要在最後用到這個值，在滑動窗口的同時累加就可以

#+BEGIN_SRC scheme :session
(define (max-satisfied customers grumpy minutes)
  (let ((len (vector-length customers)))
    (let loop ((origin-sum 0) ; 記錄不控制情緒情況下，滿意顧客數
               (extra-sum 0) ; 記錄控制情緒所能獲得的最大顧客數
               (s 0) ; 當前窗口通過控制情緒可以使其滿意的顧客數
               (i 0))
      (if (< i len)
          ;; 進窗口
          (let* ((angry? (eq? (vector-ref grumpy i) 1))
                 (current-customers (vector-ref customers i))
                 (new-origin-sum (+ origin-sum (if angry? 0 current-customers))) ; 如果沒生氣，更新origin-sum
                 (new-s (+ s (if angry? current-customers 0)))) ; 如果生氣，更新s
            (if (< i (- minutes 1))
                (loop new-origin-sum
                      new-s ; 窗口沒滿，還不用比較更新extra-sum，直接設成new-s
                      new-s
                      (+ i 1))
                (loop new-origin-sum
                      (max extra-sum new-s)
                      ;; 出窗口
                      (if (eq? (vector-ref grumpy (+ (- i minutes) 1)) 1)
                          (- new-s (vector-ref customers (+ (- i minutes) 1)))
                          new-s)
                      (+ i 1))))
          (+ origin-sum extra-sum)))))
#+END_SRC

#+RESULTS:
: #<unspecified>

*** [[https://leetcode.cn/problems/defuse-the-bomb/description/][1652. 拆炸弹]]

**** 思路

數組最長100，理論上可以直接暴力解

索引和k之間有個什麼聯繫，暫時不知道，先列出例子中所有的索引，試着找出關係

n = 4, k = 3:

| i | a | b | c |
|---+---+---+---|
| 0 | 1 | 2 | 3 |
| 1 | 2 | 3 | 0 |
| 2 | 3 | 0 | 1 |
| 3 | 0 | 1 | 2 |

看到循環數組，首先想到應該有模運算，可以發現， \(c = (i + k) \mod n\)
或者也可以把a到c看作一個滑動窗口，從左往右滑動排序後表格如下：

| window    | i（答案第i位） |
|-----------+----------------|
| (0, 1, 2) |              3 |
| (1, 2, 3) |              0 |
| (2, 3, 0) |              1 |
| (3, 0, 1) |              2 |

那在滑動過程中，能從右指針推出應該更新答案的第幾位嗎？可以的，按前面c也就是右指針和i的關係，做逆運算： \(i = (right - k) \mod n\)

再看看題目裏例子三k = -2的情況，是否有不同

n = 4, k = -2

k是負數，但是窗口長度（或寬度）肯定只能是2，還是一樣從左往右滑動

| window    | i（答案第i位） |
|-----------+----------------|
| (0, 1)    |              2 |
| (1, 2)    |              3 |
| (2, 3)    |              0 |
| (3, 0)    |              1 |

因爲題目規定k爲負數時，算當前索引前k個數的和，所以右指針加1就是索引，但注意不能溢出，還是需要模運算： \(i = (right + 1) \mod n\)

這樣一來問題就簡單了，除了k等於0時直接返回全0數組，其他情況只要維護一個長爲 =abs(k)= 的窗口，向右滑動，根據右端點索引和答案索引的關係，去更新相應的答案就可以了。

**** 代碼

#+BEGIN_SRC scheme :session
(define (decrypt code k)
  (let* ((n (vector-length code))
         (ans (make-vector n 0))
         (abs-k (abs k)))
    (if (eq? k 0)
        ans
        (let loop ((sum 0)
                   (right 0)
                   (left 0))
          (if (< left n)
              ;; 進窗口
              (let ((new-sum(+ sum (vector-ref code (modulo right n)))))
                (if (< right (- abs-k 1))
                    (loop new-sum
                          (+ right 1)
                          left) ; 先展開窗口
                    (begin
                      ;; 更新答案
                      (vector-set! ans
                                   (if (> k 0)
                                       (modulo (- right k) n)
                                       (modulo (+ right 1) n))
                                   new-sum)
                      ;; 出窗口
                      (loop (- new-sum (vector-ref code left))
                            (+ right 1)
                            (+ left 1)))))
              ans)))))
#+END_SRC

#+RESULTS:
: #<unspecified>

測試：

#+BEGIN_SRC scheme :session
(decrypt #(5 2 2 3 1) 3)
#+END_SRC

#+RESULTS:
: #(7 6 9 8 9)

** 不定長窗口

*** [[https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/][3. 无重复字符的最长子串]]

**** 思路

和定長的不同，定長左指針移動，是因爲根據題目規定，有一個代表窗口大小的k值是固定的，需要一直維持左右指針之間的距離。在這一題裏，不能維持一個固定的窗口，但是當右指針下的值，使得窗口內字符出現重複了，左指針就應該右移了。

考慮過scheme的哈希表用起來不是很舒服，而題目中聲明字符只會有英文字母、數字、符號和空格，理論上用一個128位的數組，表示上次這個ASCII字符出現的位置，應該是可以的。

**** 代碼

#+BEGIN_SRC scheme :session
(define (length-of-longest-substring s)
  (let ((last-seen (make-vector 128 -1))
        (len (string-length s)))
    (let loop ((left 0)
               (right 0)
               (ans 0))
      (if (< right len)
          (let* ((current-char (string-ref s right))
                 ;; 字符轉成ASCII碼
                 (char-ascii (char->integer current-char))
                 (char-last-index (vector-ref last-seen char-ascii))
                 ;; 如果有重複，左指針可以一步到位移動到重複字符後面
                 (new-left (max left (+ char-last-index 1))))
            ;; 右入窗口，更新last-seen
            (vector-set! last-seen char-ascii right)
            (loop new-left
                  (+ right 1)
                  ;; 更新答案
                  (max ans (+ (- right new-left) 1))))
          ans))))
#+END_SRC

#+RESULTS:
: #<unspecified>

測試：

#+BEGIN_SRC scheme :session :results table
(test length-of-longest-substring
      '((("abcabcbb") . 3)
        (("bbbbb") . 1)
        (("pwwkew") . 3)))
#+END_SRC

#+RESULTS:
| (abcabcbb) | 3 | 3 |
| (bbbbb)    | 1 | 1 |
| (pwwkew)   | 3 | 3 |

*** [[https://leetcode.cn/problems/longest-subarray-of-1s-after-deleting-one-element/description/][1493. 删掉一个元素以后全为 1 的最长子数组]]

**** 思路

找最長的，最多一個零的窗口。最後必須刪除一個元素，right減left就是答案。

**** 代碼

#+BEGIN_SRC scheme :session
(define (longest-subarray nums)
  (let ((len (vector-length nums)))
    (let loop ((last-zero -1) ; 記錄上一次出現的位置
               (left 0)
               (right 0)
               (ans 0))
      (if (< right len)
          (let* ((current-zero? (eq? (vector-ref nums right) 0))
                 (new-left (if current-zero?
                               (max (+ last-zero 1) left)
                               left)))
            (loop (if current-zero? right last-zero)
                  new-left
                  (+ right 1)
                  (max ans (- right new-left))))
          ans))))
#+END_SRC

#+RESULTS:
: #<unspecified>

測試：

#+BEGIN_SRC scheme :session
(longest-subarray #(0 1 1 1 0 1 1 0 1))
#+END_SRC

#+RESULTS:
: 5

*** [[https://leetcode.cn/problems/minimum-removals-to-balance-array/][3634. 使数组平衡的最少移除数目]]

**** 思路
排序一遍，找出最長且平衡的子數組，原數組長減子數組長就是答案

**** 代碼

#+BEGIN_SRC scheme :session
(define (min-removal nums k)
  (let* ((sorted (sort nums <))
         (nums-len (vector-length sorted)))
    (let loop ((left 0)
               (right 0)
               (max-save 0))
      (if (< right nums-len)
          (if (< (* k (vector-ref sorted left))
                 (vector-ref sorted right))
              (loop (+ left 1)
                    right
                    max-save)
              (loop left
                    (+ right 1)
                    (max max-save (+ (- right left) 1))))
          (- nums-len max-save)))))
#+END_SRC

#+RESULTS:
: #<unspecified>

測試：

#+BEGIN_SRC scheme :session
(min-removal #(2 1 5) 2)
#+END_SRC

#+RESULTS:
: 1

#+BEGIN_SRC scheme :session
(min-removal #(1 6 2 9) 3)
#+END_SRC

#+RESULTS:
: 2

#+BEGIN_SRC scheme :session
(min-removal #(4 6) 2)
#+END_SRC

#+RESULTS:
: 0

*** [[https://leetcode.cn/problems/fruit-into-baskets/][904. 水果成篮]]

**** 思路
實際就是要找一個最長的、最多包含兩種數字的子數組。

如果右指針下出現了第三種類型，左指針怎麼移？設原右指針下類型是a，窗口內另有一個類型b，右指針右移一位新進入的數字是類型c，那麼左指針應該是移到窗口內​*最後一個b的位置加一*​。

**** 代碼

#+BEGIN_SRC scheme :session
(use-modules (ice-9 match))

(define (total-fruit fruits)
  (let ((len (vector-length fruits)))
    (define loop
      (match-lambda*
        ;; 右指針到達邊界，退出
        ((_ _ _ _ _ (? (lambda (x) (>= x len)) right) ans) ans)
        ;; 初始化
        ((-1 -1 -1 -1 left right ans)
         (loop (vector-ref fruits right)
               right
               -1
               -1
               left
               (+ right 1)
               (max ans (+ (- right left) 1))))
        ((type-a index-a -1 -1 left right ans)
         (let ((current (vector-ref fruits right)))
           (if (eq? type-a current)
               (loop type-a
                     right
                     -1
                     -1
                     left
                     (+ right 1)
                     (max ans (+ (- right left) 1)))
               ;; 始終保持type-a是最新的類型
               (loop current
                     right
                     type-a
                     index-a
                     left
                     (+ right 1)
                     (max ans (+ (- right left) 1))))))
        ((type-a index-a type-b index-b left right ans)
         (let ((current (vector-ref fruits right)))
           (if (eq? current type-a)
               (loop current
                     right
                     type-b
                     index-b
                     left
                     (+ right 1)
                     (max ans (+ (- right left) 1)))
               (if (eq? current type-b)
                   (loop type-b
                         right
                         type-a
                         index-a
                         left
                         (+ right 1)
                         (max ans (+ (- right left) 1)))
                   ;; 第三種類型出現
                   (loop current ; 保持type-a是最右的類型
                         right
                         type-a ; 舊的type-a可以更新到type-b
                         index-a
                         (+ index-b 1) ; 舊的type-b離開窗口，左指針移到最後一個舊type-b的右邊
                         (+ right 1)
                         (max ans (+ (- right (+ index-b 1)) 1)))))))))
    (loop -1 -1 -1 -1 0 0 0)))
#+END_SRC

#+RESULTS:
: #<unspecified>

#+BEGIN_SRC scheme :session
(total-fruit #(1 2 1))
#+END_SRC

#+RESULTS:
: 3

#+BEGIN_SRC scheme :session
(total-fruit #(0))
#+END_SRC

#+RESULTS:
: 1

#+BEGIN_SRC scheme :session
(total-fruit #(1 0))
#+END_SRC

#+RESULTS:
: 2
